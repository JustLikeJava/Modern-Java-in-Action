# __Chapter7. 병렬 데이터 처리와 성능__
* 자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화할 수 있도록 __포크/조인 프레임워크__ 기능을 제공.
* 스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있음.

## __7.1 병렬 스트림__
* 컬렉션에 parallelStream을 호출하면 __병렬 스트림__ 이 생성됨.
* __병렬 스트림__: 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림.


### __7.1.1. 순차 스트림을 병렬 스트림으로 변환하기__
* 순차 스트림에 __parallel__ 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리됨
```java
public long parallelSum(long n){
    return Stream.iterate(1L, i -> i + 1)
                .limit(n)
                .parallel()
                .reduce(0L,Long::sum);
}
```
* 위 코드는 순차 스트림과 달리 여러 청크로 분할되어 있음.
* __sequential__ 메서드로 병렬 스트림을 순차 스트림으로 바꿀 수 있음.


### __7.1.2 스트림 성능 측정__
```java
// 순차 스트림 사용
public long sequentialSum(){
    return Stream.iterate(1L, i -> i + 1).limit(N)
                .reduce(0L, Long::sum);
}

// 전통적인 for문
public long iterativeSum(){
    long result = 0;
    for(long i = 1L;i<=N;i++){
        result += i;
    }
    return result;
}

// 최적화 되지 않은 병렬 스트림 사용
public long sequentialSum(){
    return Stream.iterate(1L, i -> i + 1).limit(N)
                .parallel()
                .reduce(0L, Long::sum);
}

// 최적화된 병렬 스트림 사용
public long parallelRangedSum(){
    return LongStream.rangeClosed(1,N)
                    .parallel()
                    .reduce(0L, Long::sum);
}
```
* 위 코드에서 최적화 되지 않은 병렬 스트림의 성능은 순차 스트림 사용과 비교해도 월등히 성능이 떨어짐. 그 이유로는
    1. 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 함.
    2. 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어려움

* 2번과 관련된 이유는 최적화 되지 않은 병렬 스트림 사용 코드를 보면 이전 연산의 결과에 따라 다음 함수의 입력이 달라져
iterate 연산을 청크로 분할하기 어렵기 때문

* 그리하여 최적화된 코드에선 __LongStream.rangeClosed__ 라는 메서드를 사용하여 다음과 같은 이점을 얻음.
    * LongStream.rangeClosed는 기본형 long을 직접 사용하므로 박싱과 언박싱 오버헤드가 사라짐.
    * LongStream.rangeClosed는 쉽게 청크로 분할할 수 있는 숫자 범위를 생산. 예를 들어 1~20 범위의 숫자를 각각
    1~5, 6~10, 11~15, 16~20 범위의 숫자로 분할 가능.

* 최적화된 코드를 통해 순차 실행보다 빠른 성능을 갖는 병렬 리듀싱을 완성.


### __7.1.3 병렬 스트림의 올바른 사용법__
* 병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 __공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 발생__
    * 병렬 스트림과 병렬 계산에선 공유된 가변 상태를 피해야 함.


### __7.1.4 병렬 스트림 효과적으로 사용하기__
* 확신이 서지 않으면 직접 측정하라
    * 벤치마크로 성능 측정

* 박싱을 주의하라
    * 되도록이면 기본형 특화스트림을 사용하자

* 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있음.
    * limit나 findFirst처럼 __요소의 순서__ 에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치뤄야 함.
    * 반면에 findAny는 요소의 순서와 상관없이 연산하여 findFirst보다 성능이 좋음.
    * 따라서 __unordered__ 를 호출하여 비정렬된 스트림을 얻어 여기에 limit를 호출하는 것이 효율적임.

* 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라
    * 처리할 요소 수를 N, 하나의 요소를 처리하는 비용을 Q라 하면 전체 스트림 파이프라인 처리비용을 N*Q로 예상 가능.
    * Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미.

* 소량의 데이터에서는 병렬 스트림이 도움 되지 않음.

* 스트림을 구성하는 자료구조가 적절한지 확인하라
    * 예를 들어 ArratList를 LinkedList보다 효율적으로 분할 가능.
    * LinkedList를 분할하려면 모든 요소를 탐색해야 하지만 ArrayList는 요소를 탐색하지 않고도 리스트를 분할할 수 있기 때문.
    * 또한 range 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해 가능.

* 스트림의 특성과 파이프라인의 중간 연산이 스트림의 득성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있음.
    * 예를 들어 SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있어 효과적으로 스트림을 병렬 처리 가능.
    * 반변 필터 연산이 있으면 스트림의 길이를 예측할 수 없어 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없음.

* 최종 연산의 병합 과정 비용을 살펴보자.


 ## __7.2 포크/조인 프레임워크__
 * __포크/조인 프레임워크__ 는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계됨.
    * 서브태스크를 스레드 풀의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현.

### __7.2.1 RecursiveTask 활용__
* 스레드 풀을 이용하려면 RecursiveTask<R>의 서브클래스를 만들어야 함. 여기서 R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는
RecursiveAction 형식임.

* RecursiveTask를 정의하려면 추상 메서드 compute를 구현해야 함.

* __compute__ 메서드는 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의.

* divide and conquer 알고리즘의 병렬화 버전.

* 예시 구현은 소스 파일 참고.

### __7.2.2 포크/조인 프레임워크를 제대로 사용하는 방법__
* join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킴.
    * 두 서브태스크가 모두 시작된 다음에 join을 호출해야 함.

* RecursiveTask 내에선 ForkJoinPool의 invoke 메서드를 사용하지 말아야 함.
    * 순차 코드에서 병렬 계산을 시작할 때만 invoke 사용.

* 한 쪽 작업엔 fork를 다른 한 쪽 작업엔 compute를 호출하는 것이 효율적.
    * 그러면 두 서브 태스크의 한 태스크엔 같은 스레드를 재사용할 수 있으므로 풀에서 불필요한 태스크를 할당하는 오버헤드를 피할 수 있음.

* 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어려움.

* 병렬 스트림에서 살펴본 것처럼 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 거란 생각은 버려야 함.
    * 각 서브태스크의 실행시간은 새로운 태스크를 포킹하는 데 드는 시간보다 길어야 함.

### __7.2.3 작업 훔치기__
* 코어 개수와 관계없이 적절한 크기로 분할된 많은 태스크를 포킹하는 것이 바람직함.

* __작업 훔치기__: ForkJoinPool의 모든 스레드를 거의 공정하게 분할.
    * 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리.
    * 이때 다른 스레드는 바쁘게 일하고 있는데 한 스레드는 할일이 다 떨어진 상황이 있을 수 있다.
    * 이때 할일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐옴.


## __7.3 Spliterator 인터페이스__
* __Spliterator__: 분할할 수 있는 반복자
    * Iterator처럼 소스의 요소 탐색 기능을 제공하는점은 같지만 Spliterator는 병렬 작업에 특화되어 있음.

* 자바8은 컬렉션 프레임워크에 포함된 모든 자료구조에 사용할 수 있는 디폴트 Spliterator 인터페이스를 구현을 제공.

* 컬렉션은 spliterator라는 메서드를 제공하는 Spliterator 인터페이스를 구현.

``` java
public interface Spliterator<T>{
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```
* T는 Spliterator에서 탐색하는 요소의 형식.
* __tryAdvance__ 메서드는 Spliterator의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환.
* __trySplit__ 메서드는 Spliterator의 일부 요소(자신이 반환한 요소)를 분할해서 두 번째 Spliterator를 생성하는 메서드.
* __estimateSize__ 메서드로 탐색해야 할 요소 수 정보를 제공.

### __7.3.1 분할 과정__
* 스트림을 여러 스트림으로 분할하는 과정은 재귀적으로 발생.

* 1단계: 첫 번째 Spliterator에 trySplit을 호출하면 두 번째 Spliterator가 생성됨.
* 2단계: 두 개의 Spliterator에 trySplit를 다시 호출하면 네 개의 Spliterator가 생성됨.
    * 이처럼 trySplit의 결과가 null이 될 때까지 이 과정을 반복함.
* 3단계: trySplit이 null을 반환했다는 것은 더 이상 자료구조를 분할할 수 없음을 의미.
* 4단계: Spliterator에 호출한 모든 trySplit의 결과가 null이면 재귀 분할 과정 종료.

* __Spliterator 특성__
    * Spliterator는 __characteristics__ 라는 추상 메서드도 정의.
    * __characteristics__ 메서드는 Spliterator 자체의 특성 집합을 포함하는 int를 반환.
    * 특성을 참고해 Spliterator를 더 잘 제어하고 최적화 가능.(특성표는 책 265페이지 [표7-2] 참고)

### __7.3.2 커스텀 Spliterator 구현하기__
* 실습으로 진행. 소스 코드 참조.
