# 7장



## 7.1 병렬 스트림



### 순차 스트림을 병렬 스트림으로 변환하기

- 순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.

```java
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(n)
                 .parallel() // 스트림을 병렬 스트림으로 변환
                 .reduce(0L, Long::sum);
}
```

#### 

### 스트림 성능 측정

- JMH 라이브러리 이용



### 병렬 스트림 효과적으로 사용하기

- 확신이 서지 않으면 직접 측정하라.
- 박싱을 주의하라.
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. (limit, findFirst, 요소의 순서에 의존하는 연산)
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.
- 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
- 스트림을 구성하는 자료구조가 적절한지 확인하라. (ArrayList를 LinkedList보다 효율적으로 분할할 수 있다.)
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
- 최종 연산의 병합 과정 비용을 살펴보라.
- 병렬 스트림이 수행되는 내부 인프라구조를 살펴보라.



## 7.2 포크/조인 프레임워크



### RecursiveTask 활용

```java
protected abstract R compute();
```

compute 메서드는 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브테스크의 결과를 생산할 알고리즘을 정의한다.

```java
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함
    모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}
```



### 포크/조인 프레임워크를 제대로 사용하는 방법

- 서브태스크가 모두 시작된 다음에 join을 호출한다.
- RecursiveTask 내에서는 ForkJoinPool의 invoke 메서드를 사용하지 말아야 한다.
- 서브태스크에 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다.
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.
- 병렬 처리로 성능을 개선하려면 태스크를 여러 독립적인 서브태스크로 분할할 수 있어야 한다.



### 작업 훔치기

- 작업 훔치기 기법에서 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다.
- 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리한다.
- 할일이 없어진 스레드는 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다.
- 모든 큐가 빌 때까지 이 과정을 반복한다.



## 7.3 Spliterator 인터페이스



### 분할 과정

- 1단계 : 첫 번째 Spliterator에 traySplit을 호출하면 두 번째 Spliterator가 생성된다.
- 2단계 : 두 개의 Spliterator에 trySplit을 다시 호출하면 네 개의 Spliterator가 생성된다.
- 3단계 : trySplit의 결과가 null이 될 때까지 이 과정을 반복한다.
- 4단계 : Spliterator에 호출한 모든 trySplit의 결과가 null이면 재귀 분할 과정이 종료된다.