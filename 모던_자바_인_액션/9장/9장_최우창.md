# Chapter 9

## 9.1 가독성과 유연성을 개선하는 리팩터링
- 람다 표현식을 이용한 코드는 다양한 요구사항 변화에 대응할 수 있도록 동작을 파라미터화

### A. 코드 가독성 개선
- 코드 가독성을 개선한다는 것은 우리가 구현한 코드를 다른 사람이 쉽게 이해하고 유지보수할 수 있게 만드는 것
    - 코드의 문서화를 잘하고, 표준 코딩 규칙을 준수하는 노력
- 3가지 리팩터링 예제
    1. 익명 클래스를 람다 표현식으로 리팩터링
    2. 람다 표현식을 메서드 참조로 리팩터링
    3. 명령형 데이터 처리를 스트림으로 리팩터링

### B. 익명 클래스를 람다 표현식으로 리팩터링하기
```java
Runnable r1 = new Runnable () {
    public void run() {
        System.out.println("Hello");
    }
};
Runnable r2 = () -> System.out.println("Hello");
```
- 모든 익명 클래스를 람다 표현식으로 바꿀 수 있는 것은 아님
    1. 익명 클래스에서 사용한 `this`와 `super`는 람다 표현식에서 다른 의미
        - 익명 클래스의 this는 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킴
    2. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다.`(섀도 변수-Shadow Variable)`
        ```java
        int a = 10;
        Runnable r1 = new Runnable () {
            public void run() {
                int a = 2; // 가릴 수 있음
                System.out.println(a);
            }
        };
        Runnable r2 = () -> {
            int a = 2; // 컴파일 에러
            System.out.println(a);
        }
        ```
    3. 람다 표현식으로 바꾸면 콘텐스트 오버로딩에 따른 모호함이 초래
        - 람다의 형식이 콘텍스트에 따라 달라지기 때문에 모호함이 발생
    
### C. 람다 표현식을 메서드 참조로 리팩터링 하기
- 메서드 참조의 메서드명으로 코드의 의도를 명확하게 알릴 수 있음
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(groupingBy(Dish::getCaloricLevel));

inventory.sort(comparing(Apple::getWeight));

int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```

### D. 명령형 데이터 처리를 스트림으로 리팩터링하기
- 스트림 API를 이용하면 문제를 직접적으로 기술할 수 있고 쉽게 병렬화할 수 있다.
```java
menu.parallelStream()
    .filter(d -> d.getCalories > 300)
    .map(Dish::getName)
    .collect(toList());
```

### E. 코드 유연성 개선

#### 함수형 인터페이스 적용
- 람다 표현식을 이용하려면 `함수형 인터페이스`가 필요

#### 조건부 연기 실행
- 보안 검사나 로깅 관련 코드
```java
if (logger.isLoggable(Log.FINER)) {
    logger.finer("Problem: " + generateDiagnostic());
}
```
- logger의 상태가 클라이언트에 노출
- 메세지를 로깅할 때마다 logger 객체 상태를 계속 확인해야 하는가?
```java
logger.log(Level.FINER, "Problem: " + generateDiagnostic());
```
- logger 객체가 적잘한 수준으로 설정되었는지 내부적으로 확인하는 `log` 메서드를 사용
- 불필요한 if문을 제거, logger 상태도 노출되지 않음
- 문제점 : logger가 활성화되어 있지 않더라도 항상 로깅 메세지를 평가
    - 람다를 이용하면 이 문제를 쉽게 해결
```java
// 새로 추가된 log 메서드의 시그니처
public void log(Level level, Supplier<String> msgSupplier) {
    if(logger.isLoggable(level)) {
        log(level, msgSupplier);
    }
}

// logger 수준이 적절하게 설정되어 있을 때만 인수로 넘겨진 람다를 내부적으로 실행
logger.log(Level.FINER, () -> "Problem: " + generateDiagnostic());
```
- 코드 가독성 뿐 아니라 캡술화도 강화

#### 실행 어라운드
- 매번 같은 준비, 종료 과정을 반복적으로 수행한다면 이를 람다로 변환
<br>

## 9.2 람다로 객체지향 디자인 패턴 리팩터링하기
- 다양한 패턴을 유형별로 정리한 것이 `디자인 패턴`

### A. 전략
- `전략 패턴`은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법
    - 알고리즘을 나타내는 `인터페이스`
    - 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 `구현 클래스`
    - 전략 객체를 사용하는 한 개 이상의 `클라이언트`

#### 람다 표현식 사용
- 람다 표현식으로 전략 디자인 패턴을 대신할 수 있음
- 구현 클래스에 해당하는 것을 람다 표현식으로 대체