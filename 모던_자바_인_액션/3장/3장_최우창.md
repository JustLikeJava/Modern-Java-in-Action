## Chapter 03

- 익명 클래스로 다양한 동작을 구현할 수 있지만 만족할 만큼 코드가 깔끔하지는 않았다.



### 3.1 람다란 무엇인가?

#### 람다 표현식

- 메서드로 전달할 수 있는 익명 함수를 단순화한 것
- 이름은 없지만, `파라미터 리스트`, `바디`, `반환 형식`, `발생할 수 있는 예외 리스트`는 가질 수 있다.
- 특징
  - **익명** : 보통의 메서드와 달리 이름이 없으므로 익명이라 표현
  - **함수** : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다.
  - **전달** : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 가능
  - **간결성** : 익명 클래스처럼 많은 잔가지 코드를 구현할 필요가 없다.
- 기존코드

``` java
Comparator<Apple> byWeight = new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
}
```

- 람다를 이용한 코드

``` java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
```

- 람다 표현식은 파라미터, 화살표, 바디로 이루어짐
  - **파라미터 리스트** : 메서드 파라미터
  - **화살표** : 람다의 파라미터 리스트와 바디를 구분
  - **람다 바디** : 람다의 반환값에 해당하는 표현식

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
     람다 파라미터     화살표               람다 바디
```

=> 람다 표현식에는 `return`이 함축되어 있으므로 `return` 문을 명시적으로 사용하지 않아도 된다.

- 종류
  - **표현식 스타일** : (parameters) -> expression
  - **블록 스타일** : (parameters) -> { statements; }



### 3.2 어디에, 어떻게 람다를 사용할까?

- `함수형 인터페이스`라는 문맥에서 람다 표현식을 사용 가능



#### 함수형 인터페이스

- 하나의 추상 메서드를 지정하는 인터페이스
- `Comparator`, `Runnable` 등

- 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달

  - 전체 표현식을 함수형 인터페이스의 인스턴스로 취급

  - 함수형 인터페이스를 구현한 클래스의 인스턴스

- `@FunctionalInterface` : 함수형 인터페이스임을 알리는 어노테이션, 추상 메서드가 한 개 이상이라면 에러 발생



#### 함수 디스크립터

- 함수형 인터페이스의 추상 메서드 `시그니처`는 람다 표현식의 `시그니처`를 가리킨다.

- 람다 표현식의 시그니처를 서술하는 메서드를 `함수 디스크립터`라고 부른다.

  => **추상 메서드의 시그니처와 람다 표현식의 시그니처가 동일해야 사용 가능**



### 3.3 람다 활용 : 실행 어라운드 패턴

- 람다의 실용적인 예제
  1. 자원 처리에 사용하는 `순환 패턴`
     - 자원을 열고, 처리한 다음, 자원을 닫는 순서
  2. 설정(setup)과 정리(cleanup)



#### 실행 어라운드 패턴

1. 초기화/준비 코드
2. 작업
3. 정리/마무리 코드

- 단계별 정리
  - 1단계 : 동작 파라미터화를 기억하라
  - 2단계 : 함수형 인터페이스를 이용해서 동작 전달
  - 3단계 : 동작 실행
  - 4단계 : 람다 전달
