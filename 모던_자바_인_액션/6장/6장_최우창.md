## Chapter 06

### 6.1 컬렉터란 무엇인가?

- Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정
  - `toList`
  - `groupingBy` : 각 키 버킷 그리고 각 키 버킷에 대응하는 요소 리스트를 값으로 포함하는 맵 생성



#### A. 고급 리듀싱 기능을 수행하는 컬렉터

- 스트림에 collect를 호출하면 스트림의 요소에 리듀싱 연산이 수행된다.

```java
List<Transaction> transactions = transactionStream.collect(Collectors.toList());
```



#### B. 미리 정의된 컬렉터

- Collectors에서 제공하는 메서드의 기능을 크게 세 가지로 구분
  - 스트림 요소를 하나의 값으로 리듀스하고 요약
  - 요소 그룹화
  - 요소 분할

<br>

### 6.2 리듀싱과 요약

```java
long howManyDishes = menu.stream().collect(Collectors.counting());

// 생략 가능
long howManyDishes = menu.stream().count();
```

- `counting` 이라는 팩토리 메서드



#### A. 스트림값에서 최댓값과 최솟값 검색

- `Collectors.maxBy`
- `Collectors.minBy`
- 스트림의 요소를 비교하는데 사용할 `Comparator`를 인수로 받는다.

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);

Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(dishCaloriesComparator));
```

- 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산에도 리듀싱 기능이 자주 사용
  - 이러한 연산을 **요약** 연산이라 부른다.



#### B. 요약 연산

- `Collectors.summingInt` 라는 특별한 요약 팩토리 메서드를 제공
  - summingInt는 객체를 int로 매핑하는 함수를 인수로 받는다.
  - 인수로 전달된 함수는 객체를 int로 매핑한 컬렉터를 반환
- `Collectors.summingLong`과 `Collectors.summingDouble` 메서드도 같은 방식으로 동작

```java
int totalCalories = menu.stream().collect(summing(Dish::getCalories));
```

- `Collectors.averagingInt`, `averagingLong`, `averagingDouble` 등 평균을 계산

```java
double avgCalories = menu.stream().collect(averagingDouble(Dish::getCalories));
```

- 종종 두 개 이상의 연산을 한 번에 수행해야 하는 경우

  - 팩토리 메서드 `summarizingInt`가 반환하는 컬렉터를 사용
  - 하나의 요약 연산으로 요소 수, 합계, 평균, 최댓값, 최솟값 등 계산

  ```java
  IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories));
  
  // menuStatistics를 출력하면
  IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
  ```

  - `summarizingDouble`, `summarizingLong` 메서드 존재



#### C. 문자열 연결

- 컬렉터에 `joining` 팩토리 메서드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 하나의 문자열로 연결 후 반환
  - 내부적으로 `StringBuilder`를 이용

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());

// toString 메소드가 구현되어 있는 경우
String shortMenu = menu.stream().collect(joining());
```

- 구분 문자열을 넣을 수 있도록 오버로드된 `joining` 팩토리 메서드 존재

```java
String shortMenu = menu.stream().collect(joining(", "));
```



#### D. 범용 리듀싱 요약 연산

- 지금까지 살펴본 모든 컬렉터는 `reducing` 팩토리 메서드로 정의 가능

- `reducing`은 인수 세 개를 받는다.
  - 첫 번째 인수는 리듀싱 연산의 **시작값**이거나 스트림에 인수가 없을 때는 **반환값**
  - 두 번째 인수는 **변환 함수**
  - 세 번째 인수는 **Operator**

```java
Optional<Dish> mostCalorieDish = menu.stream()
  .collect(reducing(
  (d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

- 한 개의 인수를 갖는 reducing 팩토리 메서드
  - 스트림의 **첫 번째 요소**를 시작 요소
  - 자신을 그대로 반환하는 **항등 함수**를 두 번째 인수
  - 빈 스트림인 경우가 있으므로 `Optional` 객체를 반환



##### 제네릭 와일드카드 '?' 사용법

- 형식이 알려지지 않았음을, 즉 형식이 자유로움을 의미한다.

<br>

##### 자신의 상황에 맞는 최적의 해법 선택

- 스트림 인터페이스에 직접 제공하는 메서드를 이용하는 것에 비해 컬렉터를 이용하는 코드가 더 복잡
- 코드가 복잡한 대신 재사용성과 커스터마이즈 가능성을 제공하는 높은 수준의 `추상화`와 `일반화` 얻을 수 있다.
- 특화된 해결책 -> 가독성과 성능 상승



##### 퀴즈 6-1 리듀싱으로 문자열 연결하기

- `reducing`은 두 인수를 받아 같은 형식을 반환하는 함수를 인수로 받는다.

<br>

### 6.3 그룹화

- 자바 8의 함수형을 이용하면 가독성 있는 한 줄의 코드로 그룹화를 구현

```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));
```

- 팩토리 메서드 `Collectors.groupingBy` 이용
  - 인수로 전달받은 함수를 **분류 함수**라고 부른다.

- 복잡한 분류 기준이 필요한 상황은 메서드 참조 대신 람다 표현식으로 필요한 로직 구현

```java
public enum CaloricLevel { DIET, NORMAL, FAT }

Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
  groupingBy(dish -> {
      if (dish.getCalories() <= 400) return CaloricLevel.DIET;
      else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
    	else return CaloricLevel.FAT;
    }
  ))
```



#### A. 그룹화된 요소 조작

```java
Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream()
  .filter(dish -> dish.getCalories() > 500)
  .collect(groupingBy(Dish::getType));
// Type 중 해당 필터를 통과하지 못한 Type은 Key 조차 Map에서 사라진다.

Map<Dish.Type, List<Dish>> caloricDishesByType = menu.stream()
  .collect(groupingBy(Dish::getType, filtering(dish -> dish.getCalories() > 500, toList())));
```

- 오버로드 된 팩토리 메서드 `groupingBy`
  - `filtering` 메서드는 또 다른 정적 팩토리 메서드로 프레디케이트를 인수로 받는다.
  - 각 그룹의 요소와 필터링 된 요소를 재그룹화

```java
Map<Dish.Type, List<String>> dishNamesByType = menu.stream()
  .collect(groupingBy(Dish::getType, mapping(Dish::getName, toList())));
```

- `mapping` 메서드를 통해 관련 이름 목록으로 변화

```java
Map<String, List<String>> dishTags;

Map<Dish.Type, Set<String>> dishNamesByType = menu.stream()
  .collect(groupingBy(Dish::getType, flatMapping(dish -> dishTags.get(dish.getName()).stream(), toSet())));
```

- 두 수준의 리스트를 한 수준으로 평면화하려면 `flatMap` 수행



#### B. 다수준 그룹화

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = 
  menu.stream().collect(
    groupingBy(Dish::getType, 
      groupingBy(dish -> {
        if (dish.getCalories() <= 400)
          return CaloricLevel.DIET;
        else if (dish.getCalories() <= 700)
          return CaloricLevel.NORMAL;
        else
          return CaloricLevel.FAT;
      })
    )
  )
```

- `groupingBy` 메서드에 두 번째 기준을 정의하는 내부 `groupingBy`를 전달
- 다수준 그룹화 연산은 다양한 수준으로 확장 가능



#### C. 서브그룹으로 데이터 수집

- `groupingBy`로 넘겨주는 컬렉터의 형식은 제약이 없다.

```java
Map<Dish.Type, Long> typesCount = menu.stream()
  .collect(groupingBy(Dish::getType, counting()));
```

- 분류 함수 한개의 인수를 갖는 `groupingBy(f)`는 사실 `groupingBy(f, toList())`의 축약형

```java
Map<Dish.Type, Optional<Dish>> mostCaloricByType = menu.stream()
  .collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));
```

- 가장 높은 칼로리를 가진 요리를 찾는 프로그램



##### 컬렉터 결과를 다른 형식에 적용하기

- 팩토리 메서드 `Collectors.collectingAndThen`으로 결과를 다른 형식으로 활용

```java
Map<Dish.Type, Dish> mostCaloricByType = menu.stream()
  .collect(groupingBy(Dish::getType, collectingAndThen(
    maxBy(comparingInt(Dish::getCalories)), Optional::get
  )));
```

- 적용할 컬렉터와 변환 함수를 인수로 받아 다른 컬렉터를 반환
- 반환되는 컬렉터는 기존 컬렉터의 래퍼 역활, `collect`의 마지막 과정에서 변환 함수로 자신이 반환하는 값을 제공