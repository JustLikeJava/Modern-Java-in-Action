# Chapter13. 디폴트 메서드
라이브러리 설계자 입장에서 인터페이스에 새로운 메서드를 추가하는 등 인터페이스를 바꾸고 싶을 때는 문제가 발생한다.
인터페이스를 바꾸면 이전에 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 하기 때문이다.
자바 8에선 이 문제를 해결하는 새로운 기능을 제공한다.

자바 8에서는 기본 구현을 포함하는 인터페이스를 정의하는 두 가지 방법을 제공한다.
1. __인터페이스 내부에 정적 메서드를 사용하는 것__
2. __인터페이스의 기본 구현을 제공할 수 있도록 디폴트 메서드 기능을 사용하는 것__

디폴트 메서드 예시(List 인터페이스의 sort 디폴트 메서드)
```java 
default void sort(Comparator<? Super E> c){
    Collections.sort(this, c);
}
```
* __default 키워드__: 해당 메서드가 디폴트 메서드임을 가리킨다.
* 위에서 sort 메서드는 Collections.sort 메서드를 호출하고 이 덕분에 리스트에 직접 sort를 호출할 수 있게 되었다.

디폴트 메서드는 주로 라이브러리 설계자들이 사용한다. 
디폴트 메서드를 이용하면 기존 구현을 고치지 않고도 인터페이스를 바꿀 수 있으므로 
자바 API의 호환성을 유지하면서 라이브러리를 바꿀 수 있다.

## 13.1 변화하는 API
디폴트 메서드를 이용해서 API를 바꾸면 새롭게 바뀐 인터페이스에서 자동으로 기본 구현을 제공하므로 기존 코드를 고치지 않아도 된다.
* __바이너리 호환성__: 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황.
* __소스 호환성__: 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 의미.
* __동작 호환성__: 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미.


## 13.2 디폴트 메서드란 무엇인가?
자바 8에선 호환성을 유지하면서 API를 바꿀 수 있도록 새로운 기능인 __디폴트 메서드__ 를 제공한다.
인터페이스를 구현하는 클래스에서 구현하지 않은 메서드는 인터페이스 자체에서 기본으로 제공한다(그래서 이를 디폴트 메서드라고 부른다.)

* 디폴트 메서드는 __default__ 라는 키워드로 시작하며 다른 클래스에 선언된 메서드처럼 메서드 바디를 포함한다.

자바 8 API에서 디폴트 메서드가 상당히 많이 활용되었다.
예를 들어 Collection 인터페이스의 stream 메서드, List 인터페이스의 sort 메서드 등이 있고 3장에서 소개한 Predicate, Function, Comparator 등 많은 함수형 인터페이스도 Predicate.and 또는 Function.andThen 같은 다양한 디폴트 메서드를 포함한다.

* __추상 클래스와 자바 8의 인터페이스 차이점__
1. 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러 개 구현할 수 있다.
2. 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다.


## 13.3 디폴트 메서드 활용 패턴
디폴트 메서드를 이용하는 두 가지 방식
1. 선택형 메서드
2. 동작 다중 상속

### 13.3.1 선택형 메서드
예를 들면 Iterator는 hasNext와 next뿐 아니라 remove 메서드도 정의한다. 
사용자들이 remove 기능은 잘 사용하지 않으므로 자바 8이전에는 remove 기능을 무시했다. 
결과적으로 Iterator를 구현하는 많은 클래스에서는 remove에 빈 구현을 제공했다.
하지만 디폴트 메서드를 이용하면 remove 같은 메서드에 기본 구현을 제공할 수 있으므로 인터페이스를 구현하는 클래스에서 빈 구현을 제공할 필요가 없다.
```java
interface Iterator<T>{
    boolean hasNext();
    T next();
    default void remove(){
        throw new UnSupportedOperationException();
    }
}
```
기본 구현을 제공해 빈 remove 메서드를 구현할 필요가 없어져 불필요한 코드를 줄였다.

### 13.3.2 동작 다중 상속
디폴트 메서드를 이용해 기존에 불가능했던 동작 다중 상속 기능을 구현 가능.

* 자바에서 클래스는 한 개의 다른 클래스만 상속할 수 있지만 인터페이스는 여러 개 구현할 수 있다.

* __다중 상속 형식__
    * 디폴트 메서드를 사용하지 않아도 다중 상속을 활용할 수 있다.
    * 자바 8에선 인터페이스가 구현을 포함할 수 있으므로 클래스는 여러 인터페이스에 동작을 상속받을 수 있다.

* __기능이 중복되지 않는 최소의 인터페이스__
    * 인터페이스의 기존 추상메서드를 이용해 디폴트 메서드를 구현할 수 있다.
    * 위와 같은 방식으로 기존 코드를 재사용한다.

* __인터페이스 조합__
    * 여러 인터페이스를 상속 받고 이들의 디폴트 메서드들을 조합하여 사용할 수 있다

* __옳지 못한 상속__
    * 예를 들어 한 개의 메서드를 재사용하려고 100개의 메서드와 필드가 정의되어 있는 클래스를 상속받는 것은 좋은 생각이 아님.
    * 이럴 땐 __delegation__, 즉 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 좋음.
    * 종종 'final'로 선언된 클래스를 볼 수 있다. 다른 클래스가 이 클래스를 상속받지 못하게 함으로써 원래 동작이 바뀌지 않길 원하기 때문.
    * 디폴트 메서드에도 이 규칙들을 적용할 수 있다. 필요한 기능만 포함하도록 인터페이스를 최소한으로 유지한다면 필요한 기능만 선택할 수 있으므로 쉽게 기능을 조립할 수 있다.


## 13.4 해석 규칙
자바 8에는 디폴트 메서드가 추가되어 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생길 수 있다.
이 절에선 자바 컴파일러가 이러한 충돌을 어떻게 해결하는지 설명한다.

### 13.4.1 알아야 할 세 가지 해결 규칙
1. 클래스가 항상 이긴다. 클래스나 슈퍼 클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 규칙 이외의 상황에서는 서브인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브인터페이스가 이긴다. 즉, B가 A를 상속받는다면 B가 A를 이긴다.
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.
