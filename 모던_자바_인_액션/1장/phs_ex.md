# Chapter1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## **1.1 역사의 흐름은 무엇인가?**
* 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어남.   

* 자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드 구현 가능.   

* 멀티코어 CPU 대중화와 같은 하드웨어적인 변화도 자바 8에 영향을 미침.   

    * 자바 8 이전의 자바 프로그램은 코어 중 하나만을 사용. (나머지 코어는 스레드를 사용하여 활용.)   
    * 스레드를 사용하면 관리하기 어렵고 많은 문제를 야기하는 단점이 있음.   
    * 그러나 자바 8은 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공.   

* 자바 8은 __간결한 코드__, __멀티코어 프로세서의 쉬운 활용__ 이라는 두 가지 요구사항을 기반으로 함.  

* 자바 8에서 제공하는 새로운 기술   

    * 스트림 API   
    * 메서드에 코드를 전달하는 기법   
    * 인터페이스의 디폴트 메서드   

## **1.2 왜 아직도 자바는 변화하는가?**
### **1.2.1 프로그래밍 언어 생태계에서 자바의 위치**
* 자바는 출발이 좋았다.
    * 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작.
    * 스레드와 락을 이용한 소소한 동시성도 지원.
    * 코드를 JVM 바이트 코드로 컴파일하는 특징 때문에 인터넷 애플릿 프로그램의 주요 언어가 됨.

* 또한 다양한 임베디드 컴퓨팅 분야를 성공적으로 장악하고 있음.

* 하지만 프로그래밍 언어 생태계에 변화의 바람이 붐.
    * 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 __빅데이터__ 를 효과적으로 처리할 필요성이 커짐.
    * 즉, __병렬 프로세싱__ 을 활용해야 하는데 지금까지의 자바로는 충분히 대응 불가능.

* 프로그래밍 언어 생태계를 요약하자면 새로운 언어가 등장하고 이는 변화하는 환경에 빠르게 적응하면서 점점 대중화됨.

* 자바 8은 더 다양한 프로그래밍 도구, 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수 가능한 장점을 제공.

### **1.2.2 스트림 처리 (자바에 추가된 첫 번째 프로그래밍 개념)**
* 스트림이란? 
    
    * 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임.
    * 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.
    * ex) 유닉스의 cat 명령어

* 자바 8에는 java.util.stream 패키지에 스트림 API가 추가됨.
    
    * 스트림 패키지에 정의된 Stream<T>는 T 형식으로 구성된 일련의 항목을 의미.

* 스트림 API의 핵심
    
    * 자바 8에서는 작업을 (데이터베이스 질의처럼) 고수준으로 추상홯서 일련의 스트림으로 만들어 처리 가능.
    * 또한 스트림 파이프라인을 이용해 입려 부분을 여러 CPU 코어에 쉽게 할당 가능한 부가적이 이득도 얻음.
    * 스레드를 사용하지 않고 공짜로 병렬성 획득 가능.

### **1.2.3 동작 파라미터화로 메서드에 코드 전달하기 (자바에 추가된 두 번째 프로그래밍 개념)**
* 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능 제공. 
    
    * 이를 이론적으로 __동작 파라미터화__ 라고 부름.

* 동작 파라미터화가 왜 중요할까?

    * 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문.

### **1.2.4 병렬성과 공유 가변 데이터 (자바에 추가된 세 번째 프로그래밍 개념)**
* 세 번째 프로그래밍의 개념은 __'병렬성을 공짜로 얻을 수 있다'__ 라는 말에서 시작.

    * 병렬성을 얻는 대신 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 함.

* 스트림 메서드로 전달하는 코드는 보통의 다른 코드와 동시에 실행해도 안전하게 실행하기 위해 공유된 가변 데이터에 접근하지 않아야 한다.

* 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사함.

    * __공유되지 않은 가변 데이터 요구사항__ 이란 수학적인 함수처럼 함수가 정해진 기능만 수행하며 다른 부작용은 일으키지 않음을 의미.

### **1.2.5 자바가 진화해야 하는 이유**
* 자바 8의 가장 큰 변화: 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 __함수형 프로그래밍__ 으로 다가섰다는 것.
    * 함수형 프로그래밍은 우리가 하려는 작업이 최우선시되며 그 작업을 어떻게 수행하는지 별개의 문제로 취급.

* 언어느 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 함.

## **1.3 자바 함수**
* 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용.
    
    * 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미.

* 자바 8에서는 함수를 새로운 값의 형식으로 추가함.
    
    * 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문.

* 그렇다면 함수가 왜 필요할까?
    
    * 프로그래밍 언어의 핵심은 값을 바꾸는 것. 그리고 이 값을 일급 값(또는 시민)이라고 부름.
    * 자바의 다양한 구조체(메서드, 클래스 같은)는 값의 구조를 표현하는 데 도움이 될 수 있지만 프로그램을 실행하는 동안 이러한 모든 구조체를
    자유롭게 전달할 수는 없음. 이렇게 전달할 수 없는 구조체는 이급 시민이라고 부름.
    * 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용 가능.
    * 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가.

### **1.3.1 메서드와 람다를 일급 시민으로**
* 메서드 참조
    * 코드 예시
    ```
    // 숨겨진 파일 필터링하는 코드
    // 자바 8 이전
    File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
        public boolean accept(File file){
            return file.isHidden();
        }
    })
    
    // 자바 8
    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```
    * isHidden이라는 함수는 준비되어 있으므로 자바 8의 메서드 참조를 이용해 listFiles에 직접 전달. (메서드가 아닌 함수라는 용어를 사용한 것을 주목하자.)
    * 기존에 비해 문제 자체를 더 직접적으로 설명한다는 점이 자바 8코드의 장점.
    * 자바 8에서는 메서드는 일급값.

### **람다 : 익명 함수**
* 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 __람다__ 를 포함하여 __함수__ 도 값으로 취급 가능.
    * ex) `(int x) -> x + 1 // x라는 인수로 호출하면 x + 1 을 반환`
    * 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현 가능.
    * 람다 문법 형식으로 구현된 프로그램을 __함수형 프로그래밍__ , 즉 '함수를 일급값으로 넘겨주는 프로그램을 구현하다'라고 한다.

### **코드 넘겨주기 : 예제 (예제 FilteringApples.java 참고)**
* 특정 조건으로 사과를 필터링하는 코드
    * 복사&붙여넣기 방식 (자바 8 이전)
    ```
    // 녹색 사과 필터링
    public static List<Apple> filterGreenApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if ("green".equals(apple.getColor())) {
            result.add(apple);
        }
        }
        return result;
    }

    // 150그램 이상의 무게를 가진 사과 필터링
    public static List<Apple> filterHeavyApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
        }
        return result;
    }
    ```
    * 복사&붙여넣기의 단점: 어떤 코드에 버그가 있다면 복사&붙여넣기한 모든 코드를 고쳐야 함.
    
    * 코드를 인수로 넘겨주는 방식 (자바 8)
    ```
    public static boolean isGreenApple(Apple apple) {
        return "green".equals(apple.getColor());
    }

    public static boolean isHeavyApple(Apple apple) {
        return apple.getWeight() > 150;
    }

    // 명확히 하기 위해 추가함(보통 java.util.function에서 import)
    public interface Predicate<T>{
        boolean test(T t);
    }

    public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
        }
        return result;
    }

    // 메서드를 전달하여 호출
    filterApples(inventory, Apple::isGreenApple); // 녹색 사과 필터링
    filterApples(inventory, Apple::isHeavyApple); // 150그램 이상의 무게를 가진 사과 필터링
    ```
    * __Predicate__ 란 무엇인가?
        * 수학에선 인수로 값을 받아 true나 false를 반환하는 함수를 Predicate라고 함.
        * 자바 8에서도 `Function<Apple, Boolean>` 같이 코드를 구현할 수 있지만 `Predicate<Apple>`을 사용하는 것이 더 표준적인 방식.
        (또한 boolean을 Boolean으로 변환하는 과정이 없으므로 더 효율적)

### **1.3.3 메서드 전달에서 람다로**
* 메서드를 값으로 전달하는 것은 유용하지만 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일.

    * 자바 8에선 이 문제를 __람다(익명 함수)__ 라는 새로운 개념을 이용하여 해결.
    * 코드 예시
    ```
    filterApples(inventory, (Apple a) -> "green".equals(a.getColor())) ; // 녹색 사과 필터링
    filterApples(inventory, (Apple a) -> a.getWeight() > 150); // 150그램 이상의 무게를 가진 사과 필터링
    // 80그램 이하의 무게를 가지거나 갈색 사과 필터링
    filterApples(inventory, (Apple a) -> a.getWeight() < 80 || "brown".equals(a.getColor()));
    ```
    * 위 코드는 더 짧고 간결하여 유용, 하지만 람다가 몇 줄 이상으로 길어진다면(복잡한 동작) 메서드를 정의하여 메서드 참조를 활용하자.
    * 코드의 명확성이 우선시되어야 함.

## **1.4 스트림**
    