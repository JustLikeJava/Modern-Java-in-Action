## Chapter 07

- 스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있다.
- 포크/조인 프레임워크

### 7.1 병렬 스트림
- 컬렉션에 `parallelStream`을 호출하면 병렬 스트림이 생성
    - 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림
```java
public long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(n)
                 .reduce(0L, Long::sum);
}
```

#### A. 순차 스트림을 병렬 스트림으로 변환하기
- 순차 스트림에 `parallel` 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리
```java
public long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(n)
                 .parallel()
                 .reduce(0L, Long::sum);
}
```
<br>

```java
stream().parallel()
        .filter(...)
        .sequential()
        .map(...)
        .parallel()
        .reduce();
```
- `parallel`과 `sequential` 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향

#### B. 스트림 성능 측정
- 성능을 최적화할 때는 세 가지 황금 규칙을 기억
    1. 첫째도 측정
    2. 둘째도 측정
    3. 셋째도 측정
- `자바 마이크로벤치마크 하니스(JMH)` 라이브러리 이용해 작은 벤치마크를 구현
    - 어노테이션 기반 방식 지원
    - 안정적으로 자바 프로그램이나 자바 가상 머신을 대상으로 하는 벤치마크를 구현
- 병렬 스트림을 사용했음에도 느린 결과
    - 반복 결과로 박싱된 객체가 만들어지므로 숫자를 더하려면 언박싱을 해야 한다.
    - 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.
    - 성능을 고려하기 위해서 `parallel` 메서드를 호출했을 때 내부 동작 이해

##### 더 특화된 메서드 사용
```java
public long rangedSum() {
    return LongStream.rangeClosed(1, N)
                     .reduce(0L, Long::sum);
}
```
- 오토박싱, 언박싱 등 오버헤드가 적기 때문에 더 좋은 성능

```java
public long parallelRangedSum() {
    return LongStream.rangeClosed(1, N)
                     .parallel()
                     .reduce(0L, Long::sum);
}
```
- 순차 실행보다 빠른 성능을 갖는 병렬 리듀싱
- 올바른 자료구조를 선택해야 병렬 실행도 최적의 성능을 발휘
- 병렬화는 완전 공짜가 아니다!
    - 스트림을 재귀적으로 분할
    - 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당
    - 결과를 하나의 값으로 합치는 작업
    - 멀티코어 간 데이터 이동은 비용이 크다
        - 코어 간에 데이터 전송 시간보다 오래 걸리는 작업만 병렬로 수행하는 것이 바람직