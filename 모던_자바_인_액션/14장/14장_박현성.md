# Chapter14. 자바 모듈 시스템
자바 9에서 가장 많이 거론되는 새로운 기능인 __모듈 시스템__

## 14.1 압력 : 소프트웨어 유추
* 추론하기 쉬운 소프트웨어를 만드는 데 도움을 주는 __관심사 분리__ 와 __정보 은닉__

### 14.1.1 관심사 분리
* __관심사 분리(SoC, Separation of concerns)__: 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙
    * 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용

* __Soc 장점__
    * 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있음
    * 개별 부분을 재사용하기 쉬움
    * 전체 시스템을 쉽게 유지보수할 수 있음.

### 14.1.2 정보 은닉
* __정보 은닉__: 세부 구현을 숨기도록 장려하는 원칙
    * 이 원칙이 중요한 이유: 소프트웨어를 개발할 때 요구사항은 자주 바뀐다. 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있음. 즉, __코드를 관리하고 보호하는데 유용한 원칙__

* __캡슐화__: 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미

### 14.1.3 자바 소프트웨어
잘 설계된 소프트웨어를 만들려면 위 두 가지 원칙을 따르는 것이 필수.
UML 다이어그램같은 도구를 이용하면 그룹 코드 간의 의존성을 시작적으로 보여줄 수 있으므로 소프트웨어를 추론하는데 도움이 됨.



## 14.2 자바 모듈 시스템을 설계한 이유

### 14.2.1 모듈화의 한계
자바 9 이전까진 모듈화된 소프트웨어 프로젝트를 만드는 데 한계가 있었음. 자바는 __클래스, 패키지, JAR__ 세 가지 수준의 코드 그룹화를 제공함. 하지만 클래스와 달리 패키지와 JAR 수준에서는 캡슐화를 거으 지원하지 않았음.

__제한된 가시성 제어__
public, protected, 패키지 수준, private 이렇게 네 가지 가시성 접근자가 있음. __하지만 패키지의 가시성 제어 기능은 유명무실한 수준__


__클래스 경로__
자바는 애플리케이션을 번들하고 실행하는 기능과 관련해 자바는 태생적으로 약점을 갖고 있다. 
클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
하지만 안타깝게도 클래스 경로와 JAR 조합에는 몇 가지 약점이 존재한다.

1. __클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없음.__
2. __클래스 경로는 명시적인 의존성을 지원하지 않음.__

자바 9 모듈 시스템을 이용하면 컴파일 타임에 ClassNotFoundException같은 종류의 에러를 모두 검출 가능.

### 14.2.2 거대한 JDK
__자바 개발 키트(JDK)__: 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합

JDK는 시간이 흐르면서 발전하고 덩치가 많이 커졌다. 이는 나중에 모바일에서 실행되는 애플리케이션이나 JDK 전부를 필요로 하지 않는 클라우드에서 문제가 되었다. 즉, __JDK에서 필요한 부분만 골라 사용하고 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 새로운 건축 구조가 필요했다.__



## 14.3 자바 모듈 : 큰 그림
자바 8은 __모듈__ 이라는 새로운 자바 프로그램 구조 단위를 제공. 모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다.
* __모듈 디스크립터__ 
    * __module-info.java__ 라는 특별한 파일에 저장됨.
    * 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킴.
    * __핵심 구조__
        * module 모듈명
        * exports 패키지명 (한 패키지를 노출시키는 간단한 형식, 퍼즐로 비유하면 돌출부)
        * requires 모듈명 (0개 이상의 모듈, 퍼즐로 비유하면 패인 부분)
    


## 14.8 모듈 정의와 구문들

### 14.8.1 requires
* requires 구문은 __컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의__ (인수: 모듈명)

### 14.8.2 exports
* exports 구문은 __지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만듦__ (인수: 패키지명)

### 14.8.3 requires transitive
* requires transitive 구문은 __다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정__

### 14.8.4 exports to
* exports to 구문은 __사용자에게 공개할 기능을 제한함으로 가시성을 좀 더 정교하게 제어할 수 있게 함__

### 14.8.5 open과 opens
* 모듈 선언에 __open__ 한정자를 이용하면 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있음.
* 리플렉션 때문에 전체 모듈을 개방하지 않고도 __opens__ 구문을 모듈 선언에 이용해 필요한 개별 패키지만 개방할 수 있음.
* exports_to로 노출한 패키지를 사용할 수 있는 모듈을 한정했던 것처럼, open에 to를 붙여서 반사적인 접근을 특정 모듈에만 허용 가능.

### 14.8.6 uses와 provides
* provides 구문으로 서비스 제공자를 uses 구문으로 서비스 소비자를 지정할 수 있는 기능을 제공




