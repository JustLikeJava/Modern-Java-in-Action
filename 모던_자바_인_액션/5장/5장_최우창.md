## Chapter 05

- `스트림 API`를 이용하여 내부적으로 최적화와 병렬 처리가 가능
  - 순차적인 반복을 단일 스레드로 구현하는 `외부 반복`으로는 달성할 수 없다.

<br>

### 5.1 필터링

- 프레디케이트 필터링 방법과 고유 요소만 필터링하는 방법



#### 프레디케이트로 필터링

- 스트림 인터페이스는 `filter` 메서드를 지원
  - **프레디케이트**를 인수로 받아서 일치하는 모든 요소를 포함하는 스트림을 반환



#### 고유 요소 필터링

- 고유 요소로 이루어진 스트림을 반환하는 `distinct` 메서드로 지원

  - 고유 여부는 스트림에서 만든 객체의 **hashCode**, **equals**로 결정

    ```java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
    numbers.stream()
      		 .filter(i -> i % 2 == 0)
      		 .distinct()
      		 .forEach(System.out::println);
    ```

<br>

### 5.2 스트림 슬라이싱

- 스트림의 요소를 선택하거나 스킵하는 다양한 방법



#### 프레디케이트를 이용한 슬라이싱

- `takeWhile`
- `dropWhile`



##### TAKEWHILE 활용

- `filter`가 존재하는데 왜 굳이 사용하는가?
  - `filter`의 방법은 전체 스트림을 반복하지만 정렬이 되어 있어 **중간에 반복을 중단**하는 경우 존재
  - 스트림의 크기가 큰 경우 전체를 반복하는 것은 소비가 큰 작업

```java
List<Dish> slicedMenu1
  = specialMenu.stream()
  						 .takeWhile(dish -> dish.getCalories() < 320)
  						 .collect(toList());
```

- 프레디케이트가 만족하지 않으면 중간에 반복이 중단



##### DROPWHILE 활용

- 나머지 요소를 선택하는 방법

```java
List<Dish> slicedMenu2
  = specialMenu.stream()
  						 .dropWhile(dish -> dish.getCalories() < 320)
  						 .collect(toList());
```

- 프레디케이트가 처음으로 거짓인 지점까지 발견된 요소를 버린다.
- 거짓인 지점에서 작업을 중단하고 남은 모든 요소를 반환
- **무한 스트림**에서도 동작

<br>

#### 스트림 축소

- 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 `limit()` 메서드 지원

```java
List<Dish> dishes = specialMenu.stream()
  														 .filter(dish -> dish.getCalories > 300)
  														 .limit(3)
  														 .collect(toList());
```

- 요소 n개를 선택한 다음에 즉시 결과를 반환
- 소스의 정렬상태를 따른다.

<br>

#### 요소 건너뛰기

- 처음 n개 요소를 제외한 스트림을 반환하는 `skip(n)` 메서드 지원
  - 요소의 개수가 n개 이하면 빈 스트림이 반환



##### 퀴즈 5-1 필터링

```java
List<Dish> dishes =
  menu.stream()
  		.filter(dish -> dish.getType() == Type.MEAT)
  		.limit(2)
  		.collect(toList());
```

<br>

### 5.3 매핑

- 특정 객체에서 특정 데이터를 선택하는 작업은 자주 수행되는 연산
- 스트림 API의 `map`과 `flatMap` 메서드는 특정 데이터를 선택하는 기능을 제공



#### 스트림의 각 요소에 함수 적용하기

- 함수를 인수로 받는 `map` 메서드를 지원

```java
List<Integer> dishNameLengths = menu.stream()
  																	.map(Dish::getName)
  																	.map(String::length)
  																	.collect(toList());
```



#### 스트림 평면화

##### map과 Arrays.stream 활용

- 문자열 배열이 존재할 때 중복되지 않는 **고유 문자**를 얻기 위한 방법
  - 배열 스트림 대신 문자열 스트림이 필요

```java
words.stream()
  	 .map(word -> word.split("")) -> 각 단어를 개별 문자열 배열로 변환
  	 .map(Arrays::stream) -> 각 배열을 별도의 스트림으로 생성
  	 .distinct()
  	 .collect(toList());
```

- 결국 스트림 리스트가 만들어지면서 문제가 해결되지는 않는다.
  - `List<Stream<String>>`



##### flatMap 사용

```java
List<String> uniqueCharacters =
  words.stream()
  		 .map(word -> word.split(""))
  		 .flatMap(Arrays::stream)
  		 .distinct()
  		 .collect(toList());
```

- `flatMap`은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑
- 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 **하나의 스트림으로 연결**하는 기능



##### 퀴즈 5-2 매핑

```java
// 1.
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
  														 .map(i -> i * i)
  														 .collect(toList());

// 2.
List<Integer> numbers1 = Arrays.asList(1, 2, 3);
List<Integer> numbers2 = Arrays.asList(3, 4);
List<int[]> pairs = number1.stream()
  												 .flatMap(i ->
                             numbers2.stream().map(j -> new int[]{i, j})
             							 )
  												 .collect(toList());

// 3.
List<Integer> numbers1 = Arrays.asList(1, 2, 3);
List<Integer> numbers2 = Arrays.asList(3, 4);
List<int[]> pairs = 
  numbers1.stream()
  				.flatMap(i ->
						numbers2.stream().filter(j -> (i+j)%3 == 0).map(j -> new int[]{i, j})
          )
  				.collect(toList());
```

<br>

### 5.4 검색과 매칭

- 특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리
- `allMatch`, `anyMatch`, `noneMatch`, `findFirst`, `findAny` 등



#### 프레디케이트가 적어도 한 요소와 일치하는지 확인

```java
if(menu.stream().anyMatch(Dish::isVegetarian)) {
  System.out.println("The menu is (somewhat) vegetarian friendly!!");
}
```

- `anyMatch`는 불리언을 반환하므로 최종 연산



#### 프레디케이트가 모든 요소와 일치하는지 검사

```java
boolean isHealthy = menu.stream().allMatch(dish -> dish.getCalories() < 1000);
```



#### NONEMATCH

- 프레디케이트와 일치하는 요소가 없는지 확인

```java
boolean isHealthy = menu.stream().noneMatch(d -> d.getCalories() >= 1000);
```

=> `anyMatch`, `allMatch`, `noneMatch` 세 메서드는 스트림 `쇼트서킷` 기법을 활용

=> **쇼트 서킷**이란 표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다.

<br>

#### 요소 검색

- `findAny` 메서드는 현재 스트림에서 임의의 요소를 반환

```java
Optional<Dish> dish =
  menu.stream()
  		.filter(Dish::isVegetarian)
  		.findAny();
```



##### Optional이란?

- `Optional<T>` 클래스 : 값의 존재나 부재 여부를 표현하는 컨테이너 클래스
  - `isPresent()` : Optional이 값을 포함하면 참을 반환, 값을 포함하지 않으면 거짓을 반환
  - `ifPresent(Consumer<T> block)` : 값이 존재하면 주어진 블록을 실행
  - `T get()` : 값이 존재하면 값을 반환, 값이 없으면 NoSuchElementException 발생
  - `T orElse(T other)` : 값이 있으면 값을 반환, 없으면 기본값을 반환



#### 첫 번째 요소 찾기

```java
List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> firstSquareDivisibleByThree =
  someNumbers.stream()
  					 .map(n -> n * n)
  					 .filter(n -> n % 3 == 0)
  					 .findFirst();
```



#### 언제 사용하는가?

- `findAny`, `findFirst`가 존재하는 이유는 병렬성 때문
  - 병렬 실행에서는 첫 번째 요소를 찾기 어렵기 때문
- 병렬 스트림에서 반환 순서가 상관없으면 제약이 적은 `findAny` 사용
