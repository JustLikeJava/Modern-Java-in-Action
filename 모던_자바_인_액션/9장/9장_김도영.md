# 9장



## 9.1 가독성과 유연성을 개선하는 리팩터링



### 익명 클래스를 람다 표현식으로 리팩터링하기

```java
// 익명 클래스를 사용한 이전 코드
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello");
    }
};

// 람다 표현식을 사용한 최신 코드
Runnable r2 = () -> System.out.println("Hello");
```

- 익명 클래스에서 this는 익명클래스 자신을, 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
- 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다. 람다 표현식으로는 불가능하다.
- 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따라 모호함이 초래된다.
  - 명시적 형변환 (Task )를 이용해서 모호함을 제거할 수 있다.

### 람다 표현식을 메서드 참조로 리팩터링하기

### 명령형 데이터 처리를 스트림으로 리팩터링하기



### 코드 유연성 개선

#### 함수형 인터페이스 적용

- 조건부 연기 실행
- 실행 어라운드



#### 조건부 연기 실행

- 클라이언트 코드에서 객체 상태를 자주 확인하는 경우
- 객체의 일부 메서드를 호출하난 상황
- 내부적으로 객체의 상태를 확인한 다음에 매서드를 호출하도록 새로운 메서드를 구현하는 것이 좋다 -> 가독성 향상, 캡슐화 강화



#### 실행 어라운드

- 준비, 종료 과정을 반복적으로 수행하는 코드가 있다면 이를 람다로 변환할 수 있다.





## 9.2 람다로 객체지향 디자인 패턴 리팩터링하기



### 전략



#### 전략 디자인 패턴

- 알고리즘을 나타내는 인터페이스
- 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현
- 전략 객체를 사용하는 한 개 이상의 클라이언트



#### 람다 표현식 사용

- 전략 디자인 패턴 대체 가능



### 템플릿 메서드

- 기존 알고리즘을 사용하은데 조금은 고쳐야 하는 상황



#### 람다 표현식 사용

- 템플릿 메서드 디자인 패턴 대체 가능





### 옵저버

- 어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야 하는 상황
- GUI 애플리케이션에서 자주 등장



#### 람다 표현식 사용

- 대체 가능, 복잡하면 추천하지 않음



### 의무 체인

- 작업 처리 객체의 체인을 만들 때 사용
- 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달



### 팩토리

- 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 팩토리 디자인 패턴을 사용





## 9.3 람다 테스팅

- 단위 테스팅 진행
- 보이는 람다 표현식의 동작 테스팅
- 람다를 사용하는 메서드의 동작에 집중
- 복잡한 람다를 개별 메서드로 분할
- 고차원 함수 테스팅



## 9.4 디버깅



### 스택 트레이스 확인

- 프로그램이 메서드를 호출할 때마다 프로그램에서의 호출 위치, 호출할 때의 인수값, 호출한 메서드의 지역 변수 등을 포함한 호출 정보가 생서되며 이들 정보는 스택 프레임에 저장된다.
- 프로그램이 멈췄다면 프로그램이 어떻게 멈추게 되었는지 프레임별로 보여주는 스택 트레이스를 얻을 수 있다.
- 문제가 발생한 시점에 이르게 된 메서드 호출 리스트를 얻을 수 있다.
- 메서드 호출 리스트를 통해 문제가 어떻게 발생했는지 이해할 수 있다.