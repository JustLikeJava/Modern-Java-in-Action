# 5장
---

## 5.1 필터링

### 프레디케이트로 필터링

filter 메서드는 프레디케이트(불리언을 반환하는 함수)를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

### 고유 요소 필터링

스트림은 고유 요소로 이루어진 스트림을 반환하는 distinct 메서드도 지원한다.
고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정된다.


## 5.2 스트림 슬라이싱

### 프레디케이트를 이용한 슬라이싱

1. TAKEWHILE 활용

```java
List<Dish> slicedMenu1 = specicalMenu.stream()
                                    .takeWhile(dish -> dish.getCalories() < 320)
                                    .collect(toList());
```
스트림을 포함한 모든 스트림에 프레디케이트를 적용해 스트림을 슬라이스할 수 있다.

2. DROPWHILE 활용

```java
List<Dish> slicedMenu2 = specicalMenu.stream()
                                    .dropWhile(dish -> dish.getCalories() < 320)
                                    .collect(toList());
```
프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다.
프레디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모드 요소를 반환한다.
dropWhile은 무한한 남은 요소를 가진 무한 스트림에서도 동작한다.

### 스트림 축소

limit(n) : 주어진 값 이하의 크기를 갖는 새로운 스트림 반환

### 요소 건너뛰기

skip(n) : 처음 n개 요소를 제외한 스트림을 반환

## 5.3 매핑

### 스트림의 각 요소에 함수 적용하기

인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다. (새로운 버전을 만든다는 개념)

### 스트림 평면화

["Hello", "World"] 리스트에서 고유 문자로 이루어진 리스트를 반환해보자.

1. map과  Arrays.stream 활용

```java
words.stream()
    .map(word -> word.split("")) // 각 단어를 개별 문자열 배열로 변환
    .map(Arrays::stream) // 각 배열을 별도의 스트림으로 생성
    .distinct()
    .collect(toList());
```

각 단어를 개별 문자열로 이루어진 배열로 만든 다음에 각 배열을 별도의 스트림으로 만들 필요가 있다.

2. flatMap 사용

```java
List<String> uniqueCharacters =
    words.stream()
        .map(word -> word.split("")) // 각 단어를 개별 문자를 포함하는 배열로 변환
        .flatMap(Arrays::stream) // 생성된 스트림을 하나의 스트림으로 평면화
        .distinct()
        .collect(toList());
```

flatMap은 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.


## 검색과 매칭

### anyMatch
```java
if(menu.stream?().anyMatch(Dish::isVegetarian) {
    System.out.println("The menu is (somewhat) vegetarian friendly!!");
}
```

프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인할 때 anyMatch 메서드를 이용한다.

### allMatch
```java
boolean isHealthy = menu.stream().allMatch(dish -> dish.getCalories() < 1000);
```

allMatch 메서드는 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지 검사한다.

### noneMatch
```java
boolean isHealthy = menu.stream().noneMatch(d -> d.getCalories() >= 1000);
```

nonematch는 주어진 프레디케이트와 일치하는 요소가 없는지 확인한다.

#### anyMatch, allMatch, noneMatch 세 메서드는 스트림 쇼트서킷 기법, 즉 자바의 &&, ||와 같은 연산을 활용한다.


### Optinal 이란?

Optional<T> 클래스(java.util.Optinal)는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스다. null을 받았을 때 에러를 막기 위해 Optinal<T>를 만들었다.

- isPresent()는 Optinal이 값을 포함하면 참을 반환하고, 값을 포함하지 않으면 거짓을 반환한다.
- ifPresent(Consumer<T> block)은 값이 있으면 주어진 블록을 실행한다. Consumer 함수형 인터페이스에는 T 형식의 인수를 받으며 void를 반환하는 람다를 전달할 수 있다.
- T get()은 값이 존재하면 값을 반환하고, 값이 없으면 NoSuchElementException을 일으킨다.
- T orElse(T other)는 값이 있으면 값을 반환하고, 값이 없으면 기본값을 반환한다.


### findFirst와 findAny는 언제 사용하나?

병렬성 때문이다. 병렬 실행에서는 첫 번째 요소를 찾기 어렵다. 요소의 반환 순서가 상관없을 때에 findAny를 사용한다.
