# Chapter15. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
* __동시성__: 단일 코어 머신에서 발생할 수 잇는 프로그래밍 속성으로 실행이 서로 겹칠 수 있음.
* __병렬성__: 병렬 실행을 하드웨어 수준에서 지원.

## 15.1 동시성을 구현하는 자바 지원의 진화
멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에선 개선된 동시성 지원이 추가됨.

* 자바 7에서는 분할 그리고 정복 알고리즘의 fork/join 구현을 지원하는 RecursiveTask가 추가되었고
* 자바 8에선 스트림과 새로 추가된 람다 지원에 기반한 병렬 프로세싱이 추가됨.
* 자바는 Future를 조합하는 기능을 추가하면서 동시성을 강화했고
* 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원함.

이들 API는 다양한 웹 서비스를 이용하고 이들 정보를 실시간으로 조합해 사용자에게 제공하거나 추가 웹 서비스를 통해 제공하는 종류의 애플리케이션을 개발하는데 필수적인 기초 모델과 툴킷을 제공한다. 이 과정을 __리액티브 프로그래밍__ 이라 부르며 자바 9에선 발행-구독 프로토콜(Flow 인터페이스 추가)로 이를 지원함.

 CompletableFuture와 Flow의 궁극적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것.

 ### 15.1.1 스레드와 높은 수준의 추상화
 * 학생들이 제출한 숫자 1,000,000개를 저장한 배열을 스레드로 처리하는 예제
 ```java
 long sum = 0;
 for(int i = 0; i < 1_000_000; i++){
     sum += stats[i];
 } 
 ```
 위 코드는 한 개의 코어로 비교적 오랜 시간동안 작업을 수행함. 반면 아래 코드는 첫 스레드를 다음 처럼 실행함.
  ```java
 long sum = 0;
 for(int i = 0; i < 250_000; i++){
     sum0 += stats[i];
 } 
 ```
 그리고 네 번째 스레드는 다음으로 끝남.
 ```java
 long sum = 0;
 for(int i = 750_000; i < 1_000_000; i++){
     sum3 += stats[i];
 } 
 ```
 메인 프로그램은 네 개의 스레드를 오나성하고 자바의 .start()로 실행한 다음 .join()으로 완료될 때까지 기다렸다가 다음을 계산.
 ```java 
 sum = sum0 + ... + sum3;
 ```
이를 각 루프로 처리하는 것은 성가시며 쉽게 에러가 발생할 수 있는 구조다.
7장에서는 자바 스트림으로 외부 반복(명시적 루프) 대신 내부 반복을 통해 얼마나 쉽게 병렬성을 달성할 수 있는지 설명함.
```java
sum = Arrays.stream(stats).parallel().sum();
```
결론적으로 스트림을 이용해 스레드 사용 패턴을 __추상화__ 할 수 있다.
7장에서는 자바 7의 RecursiveTask 지원 덕분에 포크/조인 스레드 추상화로 devide and conquel 알고리즘을 병렬화하면서 멀티코어 머신에서 배열의 합을 효율적으로 계산하는 높은 수준의 방식을 제공하는 방법을 설명했다.


### 15.1.2 Executor와 스레드 풀
자바 5는 executor 프레임워크와 스레드 풀을 통해 자바 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공.

* __스레드의 문제__
    * 자바 스레드는 직접 운영체제 스레드에 접근함, 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야 하며 더욱이 운영체제 스레드의 숫자는 제한되어 있는 것이 문제.
    * 운영체제가 지원하는 스레드 수를 초과해 사용하면 자바 애플리케이션이 예상치 못한 방식으로 크래시될 수 있으므로 기존 스레드가 실행되는 상태에서 계속 새로운 스레드를 만드는 상황이 일어나지 않도록 주의해야 함.
    * 주어진 프로그램에서 사용할 최적의 자바 스레드 개수는 사용할 수 있는 하드웨어 코어의 갯수에 따라 달라짐.

* __스레드 풀 그리고 스레드 풀이 더 좋은 이유__
    * 자바 __ExecutorService__ 는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공.
    * 프로그램은 __newFixedThreadPool__ 같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용 가능.
        * 이 메서드는 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다.
        * 스레드 풀에서 사용하지 않은 스레드로 제출된 태스크를 먼저 온 순서대로 실행.
        * 이들 태스크 실행이 종료되면 이들 스레드를 풀로 반환.
    * 위 방식의 장점은 __하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점__ 이다.
    * 프로그래머는 __태스크(Runnable이나 Callable)__ 를 제공하면 __스레드__ 가 이를 실행한다.


* __스레드 풀 그리고 스레드 풀이 나쁜 이유__
    거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하지만 두 가지 "사항"을 주의해야 한다.

    1. k 스레드를 가진 스레드 풀은 오직 k 만금의 스레드를 동시에 실행 가능. 초과로 제출된 태스크는 큐에 저장되며 이전 태스크 중 하나가 종료되기 전까진 스레드에 할당하지 않는다. __보통은 문제가 되지 않지만 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야 한다.__ 작업 스레드에서 실행 중인 활성 태스크 중 자거나 I/O, 네트워크 연결을 기다리는 태스크가 있다면 큐에 있는 나머지 태스크들은 이들이 실행될 때까지 기다려야 하므로 병렬 실행 성능이 저하됨.

    2. 중요한 코드를 실행하는 스레드가 죽는 일이 발생하지 않도록 보통 자바 프로그램은 main이 반환하기 전에 모든 스레드의 작업이 끝나길 기다린다. 따라서 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다.


### 15.1.3 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
* __엄격한 포크/조인__: 스레드 생성과 join()이 한 쌍처럼 중첩된 메서드 호출 내에 추가되는 경우.
* 시작된 태스크를 내부 호출이 아니라 외부 호출에서 종료하도록 기다리는 좀 더 여유로운 방식의 포크/조인을 사용해도 비교적 안전하다.
* 15장에서는 사용자의 메서드 호출에 의해 스레드가 생성되고 메서드를 벗어나 계속 실행되는 동시성 형태에 초점을 둔다.

* __비동기 메서드__: 메서드 호출자에 기능을 제공하도록 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드.
    * __따르는 위험성__
        * 스레드 실행은 메서드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않도록 주의해야 한다.
        * 기존 실행 중이던 스레드가 종료되지 않은 상황에서 자바의 main() 메서드가 반환하면 어떻게 될까? 다음과 같은 두가지 방법이 있는데 어는 방법도 안전하지 못하다.
            1. 애플리케이션을 종료하지 못하고 모든 스레드가 실행을 끝낼 때까지 기다린다.
            2. 애플리케이션 종료를 방해하는 스레드를 강제종료 시키고 애플리케이션을 종료한다.
            * 위와 같은 문제가 발생하지 않도록 애플리케이션 종료 전 스레드 풀을 포함한 모든 스레드를 종료하는 것이 좋다.

* 자바 스레드는 __setDaemon()__ 메서드를 이용해 __데몬__ 또는 __비데몬__ 으로 구분시킬 수 있다.
    * __데몬 스레드__: 애플리케이션이 종료될 때 강제 종료되므로 디시크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용 가능.
    * __비데몬 스레드__: main() 메서드는 이 스레드가 종료될 때까지 프로그램을 종료하지 않고 기다린다.


### 15.1.4 스레드는 무엇을 바라는가?
일반적으로 모든 하드웨어 스레드를 활용해 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는 것이 목표다(하지만 태스크 변환 비용을 고려해 너무 작은 크기는 아니어야 한다).



## 15.2 동기 API와 비동기 API
다음과 같은 시그니처를 갖는 f,g 두 메서드(두 메서드의 수행시간은 오래 걸린다고 가정)의 호출을 합하는 예제를 살펴보자
```java
int y = f(x);
int z = g(x);
System.out.println(y+z);
```
```java
class ThreadExample{
    public static void main(String[] args) throws InterruptedException{
        int x = 1337;
        Result result = new Result();

        Thread t1 = new Thread(() -> { result.left = f(x); });
        Thread t2 = new Thread(() -> { result.right = g(x); });

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(result.left + result.right);
    }

    private static class Result{
        private int left;
        private int right;
    }
}
```
이처럼 Runnable을 사용하면서 작업시간을 단축할 수 있었지만 이전의 단순했던 코드가 이렇게 변해버렸다.
Runnable 대신 __Future API 인터페이스__ 를 이용해 코드를 더 단순화할 수 있다.
```java
public class ExecutorServiceExample{
    public static void main(String[] args) throws ExecutionException, InterruptedException{
        int x = 1337;
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        Future<Integer> y = executorService.sumiy(() -> f(x));
        Future<Integer> z = executorService.sumiy(() -> g(x));
        System.out.println(y.get() + z.get());
 
        executorService.shutdown();
    }
}
```
여전히 이 코드도 명시적인 submit 메서드 호출 같은 불필요한 코드로 오염되었다. 
문제의 해결법은 __비동기 API__ 라는 기능으로 API를 바꿔서 해결할 수 있다.

### 15.2.1 Future 형식의 API
* 첫번째 대안.
위에 언급한 f,g 메서드의 반환값을 Future 타입으로 변경하여 사용한다.
하지만 조금 더 큰 프로그램에서는 아래와 같은 이유로 이런 방식을 사용하지 않는다.
1. 다른 상황에서는 g에도 Future 형식이 필요할 수 있으므로 API 형식을 통일하는 것이 바람직하다.
2. 병렬 하드웨어로 프로그램 실행 속도를 극대화하려면 여러 작은 하지만 합리적인 크기의 태스크로 나누는 것이 좋다.

### 15.2.2 리액티브 형식 API
* 두 번째 대안에서 핵심은 f, g의 시그니처를 바꿔 콜백 형식의 프로그래밍을 이용하는 것이다. 
* f에 추가 인수로 콜백(람다)을 전달하여 f의 바디에서는 return문으로 결과를 반환하는 대신 결과가 준비되면 이를 람다로 호출하는 태스크를 만드는 것이 비결.
하지만 이 방법을 사용할 때 아래와 같은 점들을 생각하며 사용하는 게 바람직하다.
1. if-then-else를 이용해 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 println을 호출해 원하는 기능을 수행할 수 있다.
2. 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었음. 즉 이번 예제의 경우는 Future를 이용하는 것이 더 적절하다.

* __리액티브 형식의 비동기 API는 자연스럽게 일련의 값(나중에 스트림으로 연결)을, Future 형식의 API는 일회성의 값을 처리하는 데 적합__


### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주


### 15.2.4. 현실성 확인
* 모든 동작을 비동기로 구현하는 것은 좋지만은 않다. 
* 실제로 자바의 개선된 동시성 API를 이용해 유익을 얻을 수 있는 상황을 찾아보고 모든 API를 비동기로 만드는 것을 따지지 말고 개선된 동시성 API를 사용해보는 걸 권장한다. 



## 15.3 박스와 채널 모델
동시성 모델을 가장 잘 설계하고 개념화하려면 그림이 필요하다. 우리는 이 기법을 __박스와 채널 모델__ 이라고 부른다.
* 박스와 채널 모델을 이용해 생각과 코드를 구조화할 수 있고 대규모 시스템 구현의 추상화 수준을 높일 수 있음.


## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
* 자바 8에선 Future 인터페이스의 구현인 CompletableFuture를 이용해 Future를 조합할 수 있는 기능을 추가했다.(16장에서 자세히 알아봄)


## 15.5 발생-구독 그리고 리액티브 프로그래밍
* 자바 9에선 __java.util.concurrent.Flow__ 의 인터페이스에 발행-구독 모델을 적용해 리액티브 프로그래밍을 제공한다.(17장에서 자세히 알아봄)
* Flow 인터페이스의 개념을 복잡하게 만든 두 가지 기능은 __압력__ 과 __역압력__ 이다.
    * __압력__
        * 예시) 기존의 온도계 예제에서 온도계가 매 초마다 온도를 보고했는데 기능이 업그레이드되면서 매 밀리초마다 온도계를 보고한다고 가정하자.
        이렇게 빠른 속도로 발생하는 이벤트를 처리하는 경우.

    * __역압력__ : 정보의 흐름 속도를 제어, 압력을 제어하는 행동


## 15.6 리액티브 시스템 vs 리액티브 프로그래밍
* __리액티브 시스템__: 런타임 환경이 변화에 대응하도록 전체 아키텍처가 설계된 프로그램.
    * 리액티브 시스템이 가져야 할 공식적인 속성
        1. __반응성__: 리액티브 시스템이 큰 작업을 처리하느라 간단한 질의의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것을 의미.
        2. __회복성__: 한 컴포넌트의 실패로 전체 시스템이 실패하지 않음을 의미.
        3. __탄력성__: 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을 의미

    * 여러 가지 방법으로 위의 속성을 구현할 수 있지만 Flow 관련된 자바 인터페이스에서 제공하는 __리액티브 프로그래밍__ 형식을 이용하는 것도 주요 방법 중 하나다.




