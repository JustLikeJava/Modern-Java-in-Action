# Chapter1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## **1.1 역사의 흐름은 무엇인가?**
* 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어남.   

* 자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드 구현 가능.   

* 멀티코어 CPU 대중화와 같은 하드웨어적인 변화도 자바 8에 영향을 미침.   

    * 자바 8 이전의 자바 프로그램은 코어 중 하나만을 사용. (나머지 코어는 스레드를 사용하여 활용.)   
    * 스레드를 사용하면 관리하기 어렵고 많은 문제를 야기하는 단점이 있음.   
    * 그러나 자바 8은 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공.   

* 자바 8은 __간결한 코드__, __멀티코어 프로세서의 쉬운 활용__ 이라는 두 가지 요구사항을 기반으로 함.  

* 자바 8에서 제공하는 새로운 기술   

    * 스트림 API   
    * 메서드에 코드를 전달하는 기법   
    * 인터페이스의 디폴트 메서드   

## **1.2 왜 아직도 자바는 변화하는가?**
### **1.2.1 프로그래밍 언어 생태계에서 자바의 위치**
* 자바는 출발이 좋았다.
    * 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작.
    * 스레드와 락을 이용한 소소한 동시성도 지원.
    * 코드를 JVM 바이트 코드로 컴파일하는 특징 때문에 인터넷 애플릿 프로그램의 주요 언어가 됨.

* 또한 다양한 임베디드 컴퓨팅 분야를 성공적으로 장악하고 있음.

* 하지만 프로그래밍 언어 생태계에 변화의 바람이 붐.
    * 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 __빅데이터__ 를 효과적으로 처리할 필요성이 커짐.
    * 즉, __병렬 프로세싱__ 을 활용해야 하는데 지금까지의 자바로는 충분히 대응 불가능.

* 프로그래밍 언어 생태계를 요약하자면 새로운 언어가 등장하고 이는 변화하는 환경에 빠르게 적응하면서 점점 대중화됨.

* 자바 8은 더 다양한 프로그래밍 도구, 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수 가능한 장점을 제공.

### **1.2.2 스트림 처리 (자바에 추가된 첫 번째 프로그래밍 개념)**
* 스트림이란? 
    
    * 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임.
    * 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.
    * ex) 유닉스의 cat 명령어

* 자바 8에는 java.util.stream 패키지에 스트림 API가 추가됨.
    
    * 스트림 패키지에 정의된 Stream<T>는 T 형식으로 구성된 일련의 항목을 의미.

* 스트림 API의 핵심
    
    * 자바 8에서는 작업을 (데이터베이스 질의처럼) 고수준으로 추상홯서 일련의 스트림으로 만들어 처리 가능.
    * 또한 스트림 파이프라인을 이용해 입려 부분을 여러 CPU 코어에 쉽게 할당 가능한 부가적이 이득도 얻음.
    * 스레드를 사용하지 않고 공짜로 병렬성 획득 가능.

### **1.2.3 동작 파라미터화로 메서드에 코드 전달하기 (자바에 추가된 두 번째 프로그래밍 개념)**
* 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능 제공. 
    
    * 이를 이론적으로 __동작 파라미터화__ 라고 부름.

* 동작 파라미터화가 왜 중요할까?

    * 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문.

### **1.2.4 병렬성과 공유 가변 데이터 (자바에 추가된 세 번째 프로그래밍 개념)**
* 세 번째 프로그래밍의 개념은 __'병렬성을 공짜로 얻을 수 있다'__ 라는 말에서 시작.

    * 병렬성을 얻는 대신 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 함.

* 스트림 메서드로 전달하는 코드는 보통의 다른 코드와 동시에 실행해도 안전하게 실행하기 위해 공유된 가변 데이터에 접근하지 않아야 한다.

* 공유되지 않은 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사함.

    * __공유되지 않은 가변 데이터 요구사항__ 이란 수학적인 함수처럼 함수가 정해진 기능만 수행하며 다른 부작용은 일으키지 않음을 의미.

### **1.2.5 자바가 진화해야 하는 이유**
* 자바 8의 가장 큰 변화: 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 __함수형 프로그래밍__ 으로 다가섰다는 것.
    * 함수형 프로그래밍은 우리가 하려는 작업이 최우선시되며 그 작업을 어떻게 수행하는지 별개의 문제로 취급.

* 언어느 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 함.

## **1.3 자바 함수**
* 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용.
    
    * 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미.

* 자바 8에서는 함수를 새로운 값의 형식으로 추가함.
    
    * 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문.

* 그렇다면 함수가 왜 필요할까?
    
    * 프로그래밍 언어의 핵심은 값을 바꾸는 것. 그리고 이 값을 일급 값(또는 시민)이라고 부름.
    * 자바의 다양한 구조체(메서드, 클래스 같은)는 값의 구조를 표현하는 데 도움이 될 수 있지만 프로그램을 실행하는 동안 이러한 모든 구조체를
    자유롭게 전달할 수는 없음. 이렇게 전달할 수 없는 구조체는 이급 시민이라고 부름.
    * 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용 가능.
    * 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가.

### **1.3.1 메서드와 람다를 일급 시민으로**
* 메서드 참조
    * 코드 예시
    ```
    // 숨겨진 파일 필터링하는 코드
    // 자바 8 이전
    File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
        public boolean accept(File file){
            return file.isHidden();
        }
    })
    
    // 자바 8
    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```
    * isHidden이라는 함수는 준비되어 있으므로 자바 8의 메서드 참조를 이용해 listFiles에 직접 전달. (메서드가 아닌 함수라는 용어를 사용한 것을 주목하자.)
    * 기존에 비해 문제 자체를 더 직접적으로 설명한다는 점이 자바 8코드의 장점.
    * 자바 8에서는 메서드는 일급값.

### **람다 : 익명 함수**
* 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 __람다__ 를 포함하여 __함수__ 도 값으로 취급 가능.
    * ex) `(int x) -> x + 1 // x라는 인수로 호출하면 x + 1 을 반환`
    * 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현 가능.
    * 람다 문법 형식으로 구현된 프로그램을 __함수형 프로그래밍__ , 즉 '함수를 일급값으로 넘겨주는 프로그램을 구현하다'라고 한다.

### **코드 넘겨주기 : 예제 (예제 FilteringApples.java 참고)**
* 특정 조건으로 사과를 필터링하는 코드
    * 복사&붙여넣기 방식 (자바 8 이전)
    ```
    // 녹색 사과 필터링
    public static List<Apple> filterGreenApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if ("green".equals(apple.getColor())) {
            result.add(apple);
        }
        }
        return result;
    }

    // 150그램 이상의 무게를 가진 사과 필터링
    public static List<Apple> filterHeavyApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
        }
        return result;
    }
    ```
    * 복사&붙여넣기의 단점: 어떤 코드에 버그가 있다면 복사&붙여넣기한 모든 코드를 고쳐야 함.
    
    * 코드를 인수로 넘겨주는 방식 (자바 8)
    ```
    public static boolean isGreenApple(Apple apple) {
        return "green".equals(apple.getColor());
    }

    public static boolean isHeavyApple(Apple apple) {
        return apple.getWeight() > 150;
    }

    // 명확히 하기 위해 추가함(보통 java.util.function에서 import)
    public interface Predicate<T>{
        boolean test(T t);
    }

    public static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
        }
        return result;
    }

    // 메서드를 전달하여 호출
    filterApples(inventory, Apple::isGreenApple); // 녹색 사과 필터링
    filterApples(inventory, Apple::isHeavyApple); // 150그램 이상의 무게를 가진 사과 필터링
    ```
    * __Predicate__ 란 무엇인가?
        * 수학에선 인수로 값을 받아 true나 false를 반환하는 함수를 Predicate라고 함.
        * 자바 8에서도 `Function<Apple, Boolean>` 같이 코드를 구현할 수 있지만 `Predicate<Apple>`을 사용하는 것이 더 표준적인 방식.
        (또한 boolean을 Boolean으로 변환하는 과정이 없으므로 더 효율적)

### **1.3.3 메서드 전달에서 람다로**
* 메서드를 값으로 전달하는 것은 유용하지만 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일.

    * 자바 8에선 이 문제를 __람다(익명 함수)__ 라는 새로운 개념을 이용하여 해결.
    * 코드 예시
    ```
    filterApples(inventory, (Apple a) -> "green".equals(a.getColor())) ; // 녹색 사과 필터링
    filterApples(inventory, (Apple a) -> a.getWeight() > 150); // 150그램 이상의 무게를 가진 사과 필터링
    // 80그램 이하의 무게를 가지거나 갈색 사과 필터링
    filterApples(inventory, (Apple a) -> a.getWeight() < 80 || "brown".equals(a.getColor()));
    ```
    * 위 코드는 더 짧고 간결하여 유용, 하지만 람다가 몇 줄 이상으로 길어진다면(복잡한 동작) 메서드를 정의하여 메서드 참조를 활용하자.
    * 코드의 명확성이 우선시되어야 함.

## **1.4 스트림**
<<<<<<< HEAD
* 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있음.

* 컬렉션에서는 반복 과정을 직접 처리.
    
    * for-each 루프를 이용해서 각 요소를 반복하며 작업 수행 -> __외부 반복__

* 반면 스트림 API를 사용하면 루프를 신경 쓸 필요가 없음.
    
    * 라이브러리 내부에서 모든 데이터가 처리됨 -> __내부 반복__

### **1.4.1 멀티스레딩은 어렵다**
* 이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해 병렬성을 이용하는 것은 쉽지 않다.

    * 멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신 가능.
    * 스레드를 잘 제어하지 못하면 원치 않은 결과가 나올 수 있음.
    * 멀티스레딩 모델은 순차적 모델보다 다루기 어려움.

* 자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제', '멀티코어 활용 어려움'이라는 두 가지 문제 모두 해결.
    * 반복되는 패턴으로 주어진 조건에 따라 데이터를 __필터링, 추출, 그룹화__ 하는 기능 존재.
    * 위의 과정을 쉽게 병렬화하는 과정
        1. 두 CPU를  가진 환경에서 리스트 필터링할 때 한 CPU는 리스트의 앞부분, 다른 CPU는 뒷부분을 처리하도록 요청 (__포킹단계__)
        2. 각각의 CPU는 자신이 맡은 절반의 리스트 처리.
        3. 마지막으로 하나의 CPU가 두 결과를 정리.

* 컬렉션은 '어떻게 데이터를 저장하고 접근할지'에, 스트림은 '데이터에 어떤 계산을 할 것인지 묘사하는 것'에 중점을 둠.

* 스트림은 __스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다__ 는 것이 핵심.

* 자바의 병렬성과 공유되지 않은 가변 상태(자바 8의 두 가지 요술방망이)
    
    1. 라이브러리에서 분할 처리, 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할.
    2. filter와 같은 라이브러리 메서드로 전달된 메서드가 __상호작용을 하지 않는다면__ 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있음.
        * 함수형 프로그래밍에서 함수형이란 __'함수를 일급값으로 사용'__ 이라는 의미도 있지만 부가적으로
        __'프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않음'__ 이라는 의미도 포함.

## **1.5 디폴드 메서드와 자바 모듈**
* 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있음.
    
    * 기존의 자바는 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부.
    * 이러한 패키지의 인터페이스를 바꿔야 하는 상황에선 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 하는 문제점이 있음.

* 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공해 패키지 모음을 포함하는 모듈을 정의 가능
    
    * 덕분에 JAR 같은 컴포넌트에 구조를 적용 가능하고 문서화와 모듈 확인 작업이 용이해짐.

* 자바 8은 인터페이스를 쉽게 바꿀 수 있도록 __디폴트 메서드__ 를 지원.
    
    * 디폴트 메서드는 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능.

* 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공
    
    * 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함(그래서 이를 __디폴트 메서드__ 라고 부름).
    * 디폴트 메서드를 이용하면 기존의 코드를 건즈리지 않고 원래의 인터페이스 설계를 자유롭게 확장 가능.
    * 자바 8에서는 인터페이스 규격명세에 __default__ 라는 새로운 키워드 지원.
    * 코드 예시
    ```
    // 예를 들어 자바 8에서는 List에 직접 sort 메서드 호출 가능.
    // 자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되어서
    default void sort(Comparator<? super E> c){
        Collection.sort(this, c); // 정적 메서드인 Colletions.sort를 호출
    }
    ```
* 하나의 클래스에서 여러 인터페이스를 구현할 수 있지 않은가?
    
    * 그러므로 다중 디폴트 메서드가 존재 가능한 것은 다중 상속이 허용된다는 의미일까? -> 엄밀히 다중상속으 아니지만 어느 정도는 '그렇다'

## **1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어**
* 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공.

    * Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체.

* (구조적) 패턴 매칭 기법

    * 수학에서 사용되는 패턴 매칭 예제
    ```
    f(0) = 1
    f(n) = n*f(n-1) // 그렇지 않으면
    ```
    * 여기서 말하는 패턴 매칭은 if-then-else가 아닌 케이스로 정의하는 수학과 함수형 프로그래밍의 기능을 의미.
    * 자바에서의 패턴 매칭 문법은 19장에서 설명, 자바 8은 패턴 매칭을 환벽하게 지원하지 않음.
    * 지금은 패턴 매칭이 switch를 확장한 것으로 데이터 형식 분류와 분석을 한 번에 수행 가능한 정도로 생각하자.
    * 자바의 switch문에는 문자열과 기본값만 이용 가능, but 함수형 언어는 보통 패턴 매칭을 포함한 다양한 데이터 형식을 switch에 사용 가능.
    


=======
    
>>>>>>> Chapter1_phs
