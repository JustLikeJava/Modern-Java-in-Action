# Chapter2. 동작 파라미터화 코드 전달하기

* 변화하는 요구사항은 소프트웨어 엔지니어링에서 피할 수 없는 문제.

    * 이에 대응하기 위해서는 우리의 엔지니어링적인 비용이 가장 최소화될 수 있으면 좋음.
    * 그뿐 아니라 새로 추가한 기능은 쉽게 구현할 수 있어야 하고 장기적인 관점에서 유지보수가 쉬워야 함.

* __동작 파라미터화__ 를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응 가능.

    * 동작 파라미터화란 __아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록__ 을 의미.
    * 즉 코드 블록의 실행은 나중으로 미뤄지고 결과적으로 코드 블록에 따라 메서드의 동작이 파라미터화 됨.

## **2.1 변화하는 요구사항에 대응하기**
### **2.1.1 첫 번째 시도: 녹색 사과 필터링**
```java
enum Color{RED, GREEN}

public static List<Apple> filterGreenApples(List<Apple> inventory){
    List<Apple> result = new ArrayList<>(); 
    for(Apple apple: inventory){
        if(GREEN.equals(apple.getColor())){ // 녹색 사과만 선택
            result.add(apple);
        }
    }
    return result;
}
```
* 이러한 코드를 작성했을 때 빨간 사과도 필터링하고 싶어졌을 땐 어떻게 고쳐야 할까?
    * 복사&붙여넣기해서 if문의 조건을 바꾸는 방법이 있다.
    * 하지만 이와 같은 방법은 더 다양한 색으로 필터링하는 등의 변화에는 적절하게 대응할 수 없다.

* 이런 상황에서의 좋은 규칙: __거의 비슷한 코드가 반복 존재한다면 그 코드를 추상화한다.__


### **2.1.2 두 번째 시도: 색을 파라미터화**
```java
public static List<Apple> filterGreenApples(List<Apple> inventory, Color color){
    List<Apple> result = new ArrayList<>(); 
    for(Apple apple: inventory){
        if(apple.getColor().equals(color)){ // 파라미터로 전달받은 color를 활용해 선택
            result.add(apple);
        }
    }
    return result;
}

List<Apple> greenApples = filterApplesByColor(inventory, GREEN);
List<Apple> redApples = filterApplesByColor(inventory, RED);
```
* 색을 파라미터화할 수 있도록 메서드에 파라미터를 추가해 변화하는 요구사항에 더 유연하게 대응하는 코드를 만들 수 있음.

* 하지만 무게를 기준으로 필터링하고 싶다면?
```java
public static List<Apple> filterGreenApples(List<Apple> inventory, int weight){
    List<Apple> result = new ArrayList<>(); 
    for(Apple apple: inventory){
        if(apple.getWeight() > weight){ // 파라미터로 전달받은 weight를 활용해 선택
            result.add(apple);
        }
    }
    return result;
}
```
* 위 코드도 좋은 해결책이라 할 수 있음. 

* 하지만 목록을 검색하고, 각 사과에 필터링 조건을 적용하는 부분의 코드가 색 필터링 코드와 대부분 중복됨.
    * 이는 소프트웨어 공학의 __DRY(don't repeat yourself)__ 원칙을 어기는 것.

* 색과 무게를 filter라는 메서드로 합치는 방법도 있음.

    * 어떤 기준으로 사과를 필터링할지 구분하는 또 다른방법인 플래그를 추가해 코드를 작성하는 방법이 있음.
    * 하지만 실전에선 절대 이 방법을 사용하지 말아야 함. (2.1.3에서 보여주는 방법이 이 방법)


### **2.1.3 세 번째 시도: 가능한 모든 속성으로 필터링**
* __앞서 말한 실전에서 절대 사용하지 말아야 할 방법!__ 이라 생략.


## **2.2 동작 파라미터화**
* 2.1절에서 파라미터를 추가하는 방법이 아닌 변화하는 요구사항에 좀 더 유연하게 대응할 수 있는 방법이 필요함을 확인.

* 사과의 어떤 속성에 기초해서 Boolean값을 반환하는 방법
    * __프레디케이트__: 참 또는 거짓을 반환하는 함수

* 선택 조건을 결정하는 인터페이스를 정의하자.
```java
public interface ApplePredicate{
    boolean test(Apple apple);
}

public class AppleHeavyWeightPredicate implements ApplePredicate{ // 무거운 사과만 선택.
    public boolean test(Apple apple){
        return apple.getWeight() > 150;
    }
}

public class AppleGreenColorPredicate implements ApplePredicate{ // 녹색 사과만 선택.
    public boolean test(Apple apple){
        return GREEN.equals(apple.getColor());
    }
}
```
* 위 조건에 따라 filter 메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 __전략 디자인 패턴__ 라고 부름.

    * 전략 디자인 패턴은 각 알고리즘을 캡슐화하는 알고리즘 패밀리르 정의해둔 다음에 
    런타임에 알고리즘을 선택하는 기법
    * 우리 예제에선 ApplePredicate가 알고리즘 패밀리, AppleHeavyWeightPredicate와 
    AppleGreenColorPredicate가 전략

* ApplePredicate는 어떻게 다양한 동작을 수행할까?

    * filterApples에서 ApplePredicate 객체를 받아 애플의 조건을 검사하도록 메소드를 수정해야 함.
    * 이렇게 동작 파라미터화, 즉 메서드가 다양한 동작을 받아서 내부적으로 다양한 동작 수행 가능.

### **2.2.1 네 번째 시도: 추상적 조건으로 필터링**
* ApplePredicate를 사용해 수정한 filter 메서드
```java
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p){
    List<Apple> result = new ArrayList<>(); 
    for(Apple apple: inventory){
        if(p.test(apple)){ // 프레디케이트 객체로 사과 검사 조건을 캡슐화했다.
            result.add(apple);
        }
    }
    return result;
}
```
### **코드/동작 전달하기**
* 위의 코드를 통해 첫 번째 코드에 비해 더 유연한 코드를 얻었고 동시에 
가독성도 좋아졌을 뿐 아니라 사용하기도 쉬워짐.

* 이제 다양한 ApplePredicate를 만들어 filterApples 메서드로 전달 가능.

    * 요구사항에 맞게 ApplePredicate를 적절하게 구현하는 클래스만 만들면 됨.
```java
public class AppleRedAndHeavyPredicate implements ApplePredicate{ // 무겁고 빨간 사과 선택.
    public boolean test(Apple apple){
        return apple.getWeight() > 150
        && RED.equals(apple.getColor());
    }
}

List<Apple> redAndHeavyApples = filterApples(inventory, new AppleRedAndHeavyPredicate());
```
* 이는 filterApples 메서드의 동작을 파라미터화한 것.

* 위 예제에서 가장 중요한 구현은 test 메서드

    * filterApples 메서드의 새로운 동작을 정의하는 것이 test 메서드
    * 하지만 메서드는 객체만 인수로 받으므로 test 메서드를 ApplePredicate 객체로 감싸서 전달해야 함.
    * test 메서드를 구현하는 객체를 이용해 boolean 표현식 등을 전달 가능하므로 '코드를 전달' 가능한 것과 다름없음.

### **한 개의 파라미터, 다양한 동작**
* 동작 파라미터화의 강점: 컬렉션 탐색 로직과 각 항목에 적용할 동작을 분리할 수 있다는 것.

