# Chapter 17 리액티브 프로그래밍

> 리액티브 너무 어렵습니다<br>
> 천천히 다시 공부해야겠습니다

`빅데이터` : 보통 데이터는 매일 증가<br>
`다양한 환경` : 모바일 디바이스에서 클라우드 기반 클러스터까지 다양한 환경에 애플리케이션 배포<br>
`사용 패턴` : 1년 내내 항상 서비스를 이용

- 사물인터넷이 적용된 미래에는 상황이 더욱 심화
- `리액티브 프로그래밍`은 비동기적으로 처리하고 합쳐서 이런 문제 해결

## 1. 리액티브 매니패스토
- `반응성` : 빠를 뿐 아니라 일정하고 예상할 수 있는 반응 시간을 제공
- `회복성` : 장애가 발생해도 시스템은 반응
- `탄력성` : 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다
- `메시지 주도` : 비동기 메시지를 전달해 컴포넌트 끼리의 통신
- **스레드**보다 가벼울 뿐 아니라 개발자에게 큰 이득
- 동기 블록, 경쟁 조건, 데드락 같은 저 수준의 멀티스레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항에 더 집중
- RxJava, Akka 같은 리액티브 프레임워크는 CPU 관련 작업과 I/O 관련 작업을 분리해서 조금 더 정밀하게 풀의 크기 설정
- `리액티브 시스템`
  - 애플리케이션 중 하나가 실패해도 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍처
  - 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 주변의 다른 컴포넌트로 전파되면서 전체 시스템 장애로 이어지는 것을 막음으로 회복성을 제공
  - 고립과 비결합이 회복성의 핵심이라면 탄력성의 핵심은 위치 투명성
  - 위치 투명성은 리액티브 시스템 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든 서비스와 통신할 수 있음을 의미
- `리액티브 애플리케이션`
  - 비교적 짧은 시간동안만 유지되는 데이터 스트림에 기반한 연산을 수행

<br>

## 2. 리액티브 스트림과 플로 API
- `리액티브 프로그래밍`
  - 리액티브 스트림을 사용하는 프로그래밍
- `java.util.concurrent.Flow`
  - Publisher
  - Subscriber
  - Subscription : 어떻게 협력하는지 설명
  - Processor : Publisher를 구독한 다음 수신한 데이터를 가공해 다시 제공

<br>

## 3. 리액티브 라이브러리 RxJava 사용하기
- 좋은 시스템 아키텍처 스타일을 유지하려면 시스템에서 오직 일부에 사용된 개념의 세부 사항을 전체 시스템에서 볼 수 있게 만들지 않아야 한다.
