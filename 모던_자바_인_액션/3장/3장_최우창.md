## Chapter 03

- 익명 클래스로 다양한 동작을 구현할 수 있지만 만족할 만큼 코드가 깔끔하지는 않았다.



### 3.1 람다란 무엇인가?

#### 람다 표현식

- 메서드로 전달할 수 있는 익명 함수를 단순화한 것
- 이름은 없지만, `파라미터 리스트`, `바디`, `반환 형식`, `발생할 수 있는 예외 리스트`는 가질 수 있다.
- 특징
  - **익명** : 보통의 메서드와 달리 이름이 없으므로 익명이라 표현
  - **함수** : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다.
  - **전달** : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 가능
  - **간결성** : 익명 클래스처럼 많은 잔가지 코드를 구현할 필요가 없다.
- 기존코드

``` java
Comparator<Apple> byWeight = new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
}
```

- 람다를 이용한 코드

``` java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> al.getWeight().compareTo(a2.getWeight());
```

- 람다 표현식은 파라미터, 화살표, 바디로 이루어짐
  - **파라미터 리스트** : 메서드 파라미터
  - **화살표** : 람다의 파라미터 리스트와 바디를 구분
  - **람다 바디** : 람다의 반환값에 해당하는 표현식

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
     람다 파라미터     화살표               람다 바디
```

=> 람다 표현식에는 `return`이 함축되어 있으므로 `return` 문을 명시적으로 사용하지 않아도 된다.

- 종류
  - **표현식 스타일** : (parameters) -> expression
  - **블록 스타일** : (parameters) -> { statements; }



### 3.2 어디에, 어떻게 람다를 사용할까?

- `함수형 인터페이스`라는 문맥에서 람다 표현식을 사용 가능



#### 함수형 인터페이스

- 하나의 추상 메서드를 지정하는 인터페이스
- `Comparator`, `Runnable` 등

- 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달

  - 전체 표현식을 함수형 인터페이스의 인스턴스로 취급

  - 함수형 인터페이스를 구현한 클래스의 인스턴스

- `@FunctionalInterface` : 함수형 인터페이스임을 알리는 어노테이션, 추상 메서드가 한 개 이상이라면 에러 발생



#### 함수 디스크립터

- 함수형 인터페이스의 추상 메서드 `시그니처`는 람다 표현식의 `시그니처`를 가리킨다.

- 람다 표현식의 시그니처를 서술하는 메서드를 `함수 디스크립터`라고 부른다.

  => **추상 메서드의 시그니처와 람다 표현식의 시그니처가 동일해야 사용 가능**



### 3.3 람다 활용 : 실행 어라운드 패턴

- 람다의 실용적인 예제
  1. 자원 처리에 사용하는 `순환 패턴`
     - 자원을 열고, 처리한 다음, 자원을 닫는 순서
  2. 설정(setup)과 정리(cleanup)



#### 실행 어라운드 패턴

1. 초기화/준비 코드
2. 작업
3. 정리/마무리 코드

- 단계별 정리
  - 1단계 : 동작 파라미터화를 기억하라
  - 2단계 : 함수형 인터페이스를 이용해서 동작 전달
  - 3단계 : 동작 실행
  - 4단계 : 람다 전달



### 3.4 함수형 인터페이스 사용

- 함수형 인터페이스의 추상 메서드 시그니처를 `함수 디스크립터`라고 한다.
- 다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요
  - 자바 8 라이브러리 설계자들은 `java.util.function` 패키지로 여러 가지 새로운 함수형 인터페이스를 제공



#### Predicate

```java
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}

Predicate<T> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
```

- `java.util.function.Predicate<T>` 인터페이스
- `test`라는 추상 메서드를 정의, 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환



#### Consumer

```java
@FunctionalInterface
public interface Consumer<T> {
  void accept(T t);
}

Consumer<T> c = (Integer i) -> System.out.println(i);
```

- `java.util.function.Consumer<T>` 인터페이스
- `accept`라는 추상 메서드를 정의, 제네릭 형식 T의 객체를 인수로 받아 동작을 수행



#### Function

```java
@FunctionalInterface
public interface Function<T, R> {
  R apply(T t);
}

Function<T, R> f = (String s) -> s.length();
```

- `java.util.function.Function<T, R>` 인터페이스
- `apply`라는 추상 메서드를 정의, 제네릭 형식 T의 객체를 인수를 받아 제네릭 형식 R 객체를 반환



#### 기본형 특화

- 자바의 모든 형식은 `참조형(reference type)` (ex) Byte, Integer, Object, List) 아니면 `기본형(primitive type)` (ex) int, double, byte, char)에 해당

- 제네릭 파라미터에는 `참조형`만 사용할 수 있다.

  - 제네릭의 내부 구현으로 인해서
  - 기본형 -> 참조형 : **박싱(boxing)**
  - 참조형 -> 기본형 : **언박싱(unboxing)**

  - 박싱과 언박싱이 자동으로 이루어지는 **오토박싱(autoboxing)**
    - 이런 변환 과정은 비용이 소모
    - 박싱한 값은 기본형을 감싸는 `래퍼`며 `힙`에 저장
    - 박싱한 값은 메모리를 더 소모하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요



#### 예외, 람다, 함수형 인터페이스의 관계

- 예외를 던지는 람다 표현식을 만들려면 확인된 예외를 선언하는 함수형 인터페이스를 직접 정의하거나 람다를 try / catch 블록으로 감싸야 한다.
  - 추상 메서드에서 예외를 던지도록 or try / catch 블록 람다 표현식



### 3.5 형식 검사, 형식 추론, 제약

- 람다로 함수형 인터페이스의 인스턴스를 만들 수 있다고 언급
- 람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않다.
  - 람다의 실제 형식을 파악해야 한다.

- 콘텍스트에서 기대되는 람다 표현식의 형식을 `대상 형식`이라고 부른다.



#### 형식 검사

1. 메서드의 선언을 확인
2. 대상 형식을 기대
3. 추상 메서드 확인
4. 함수 디스크립터 묘사
5. 람다 시그니처와 동일한지 확인
6. 형식 검사 완료
