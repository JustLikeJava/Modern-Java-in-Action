# Chapter.18 함수형 관점으로 생각하기

## 18.1 시스템 구현과 유지보수
자바 8 스트림 처리 파이프라인의 함수는 다른 누군가가 변수의 값을 바꿀 수 있는 상태에 있는 변수를 사용하지 않았다. 그래서 지금까지는 자바 8의 스트림을 이용하면 Locking 문제를 신경 쓰지 않을 수 있었다. 
그러나 실직적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 된다. 코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다.
함수형 프로그래밍이 제공하는 __no side effect, immutability__ 라는 개념이 이 문제를 해결하는 데 도움을 준다.

### 18.1.1 공유된 가변 데이터
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.
공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기가 어려워진다.

* __pure(side-effect free method) method__: 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return문을 통해서만 자신의 결과를 반환하는 메서드
    * 위에서 언급한 side-effect(부작용)은 __함수 내에 포함되지 못한 기능__ 을 뜻한다. 다음은 부작용의 예시이다.
        * 자료구조를 고치거나 필드에 값을 할당(setter 같이 생성자 이외의 초기화 동작)
        * 예외 발생
        * 파일에 쓰기 등의 I/O 동작 수행
    

### 18.1.2 선언형 프로그래밍
"How"로 접근하는 방식을 __선언형 프로그래밍__ 이라고 부르기도 한다. 선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다. 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.


### 18.1.3 왜 함수형 프로그래밍인가?
__함수형 프로그래밍__ 은 선언형 프로그래밍을 따르는 대표적인 방식이며, 부작용이 없는 계산을 지향한다. 선언형 프로그래밍과 부작용을 멀리한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.




## 18.2 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍에서 함수란 수학적인 함수와 유사하다. 즉, 함수는 0개 이상의 인수를 가지며 한 개 이상의 결과를 반환하지만 __부작용이 없어야 한다.__
__함수형__ 이란 말은 '수학의 함수처럼 부작용이 없는'을 의미한다.
결론적으로 '함수 그리고 if-then-else 등의 수학적 표현만 사용'하는 방식을 __순수 함수형 프로그래밍__, '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용'하는 방식을 __함수형 프로그래밍__ 이라 한다.


### 18.2.1 함수형 자바
실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어려워 __함수형 프로그래밍__ 을 구현할 것이다. 
* 실제로 side-effect가 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다. 
    * 필드 값을 변경하는 메서드가 있더라도 단일 스레드로 실행되는 프로그램의 입장에서는 아무 side-effect을 일으키지 않으므로 해당 메서드를 함수형이라 간주할 수 있다.

* 함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 불변 객체여야 한다.

* 함수형이라면 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
    * 예외 처리 없이 구현하기 위해 __Optional<T>__ 를 사용한다.
    * 하지만 모든 코드가 Optional을 사용하도록 반드시 고쳐야 하는 것은 아니며 함수형 프로그래밍과 순수 함수형 프로그래밍의 장단점을 실용적으로 고려해서 다른 컴포넌트에 영향을 미치지 않도록 지역적으로만 예외를 사용하는 방법도 고려할 수 있다.

* 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 side-effect를 포함하는 라이브러리 함수를 사용해야 한다.
    * 예를 들어 먼저 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 내부적으로 처리함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야 한다.


### 18.2.2 참조 투명성
'side-effect를 감춰야 한다'라는 제약은 __참조 투명성(referential transparency)__ 개념으로 귀결된다. 즉, 같은 인수로 함수로 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.
함수는 어떤 입력이 주어졌을 때 같은 결과를 생성해야 한다.(예를 들어 Random.nextInt, Scnanner로 키보드 입력을 받는 동작 등은 함수형이 될 수 없다.)


### 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍
자바 8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍의 일종으로 간주한다. 


### 18.2.4 함수형 실전 연습
List<Integer>가 주어졌을 때 이것의 모든 부분집합의 멤버로 구성된 List<List<Integer>>를 만드는 프로그램을 만든다고 가정하자.
```java
static List<List<Integer>> subsets(List<Integer> list){
    if(list.isEmpty()){ // 입력 리스트가 비어있다면 빈 리스트 자신이 서브집합이다!
        List<List<Integer>> ans = new ArrayList<>();
        ans.add(Collections.emptyList());
        return ans;
    }

    Integer first = list.get(0);
    List<Integer> rest = list.subList(1, list.size());

    List<List<Integer>> subans = subsets(rest); // 빈 리스트가 아니면 먼저 하나의 요소를 꺼내고 나머지 요소의 모든 서브집합을 찾아서 subans로 전달한다. subans는 절반의 정답을 포함한다.
    List<List<Integer>> subans2 = insertAll(first, subans); // 정답의 나머지 절반을 포함하는 subans2는 subans의 모든 리스트에 처음 꺼낸 요소를 앞에 추가해서 만든다.
    return concat(subans, subans2); // subans, subans2를 연결하면 정답이 완성된다.
}

static List<List<Integer>> insertAll(Integer first, List<List<Integer>> lists){
    List<List<Integer>> result = new ArrayList<>();
    for(List<Integer> list: lists){
        List<Integer> copyList = new ArrayList<>();
        copyList.add(first);
        copyList.addAll(list);
        result.add(copyList);
    }
    return result;
}

static List<List<Integer>> concat(List<List<Integer>> a, List<List<Integer>> b){ // 인수의 정보를 변경시키지 않고 오로지 인수에 의해 결과를 반환한다. 
    List<List<Integer>> r = new ArrayList<>(a);
    r.addAll(b);
    return r;
}
```


## 18.3 재귀와 반복
순수 함수형 프로그래밍 언어에서는 while, for 같은 반복문을 포함하지 않는다. 반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문이다.
그래서 하스켈 같은 순수 함수형 프로그래밍 언어에서는 부작용 연산을 원천적으로 제거했다. 이 경우 재귀를 이용하여 반복을 구현할 수도 있다.
하지만 재귀 코드의 경우 재귀 함수를 호출할 때마다 호출 스택에 각 호출시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어져 메모리 사용량이 증가한다.
따라서 재귀 횟수가 커지면 StackOverflowError가 발생할 가능성이 생긴다. 그래서 함수형 언어에서는 __꼬리 호출 최적화__ 라는 해결책을 제공한다.
하지만 자바에는 위에서 언급한 최적화를 자바에선 제공하지 않는다.
__자바 8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다.__